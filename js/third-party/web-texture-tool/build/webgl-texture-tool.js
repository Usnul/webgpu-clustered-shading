let J=Object.defineProperty,S=a=>J(a,"__esModule",{value:!0}),T=(a,c)=>{S(a);for(let b in c)J(a,b,{get:c[b],enumerable:!0})};const r={jpg:{format:"rgb8unorm",mimeType:"image/jpeg"},jpeg:{format:"rgb8unorm",mimeType:"image/jpeg"},png:{format:"rgba8unorm",mimeType:"image/png"},apng:{format:"rgba8unorm",mimeType:"image/apng"},gif:{format:"rgba8unorm",mimeType:"image/gif"},bmp:{format:"rgb8unorm",mimeType:"image/bmp"},webp:{format:"rgba8unorm",mimeType:"image/webp"},ico:{format:"rgba8unorm",mimeType:"image/x-icon"},cur:{format:"rgba8unorm",mimeType:"image/x-icon"},svg:{format:"rgba8unorm",mimeType:"image/svg+xml"}},B=typeof createImageBitmap!=="undefined";class z{constructor(){}static supportedExtensions(){return Object.keys(r)}async loadTextureFromUrl(a,c,b){let d=r[b.extension].format;a.supportedFormatList.indexOf(d)==-1&&(d="rgba8unorm");if(B){const e=await fetch(c),f=await createImageBitmap(await e.blob());return a.textureFromImageBitmap(f,d,b.mipmaps)}else return new Promise((e,f)=>{const i=new Image();i.addEventListener("load",()=>{e(a.textureFromImageElement(i,d,b.mipmaps))}),i.addEventListener("error",function(m){f(m)}),i.src=c})}async loadTextureFromBlob(a,c,b){let d=r[b.extension].format;a.supportedFormatList.indexOf(d)==-1&&(d="rgba8unorm");if(B){const e=await createImageBitmap(c);return a.textureFromImageBitmap(e,d,b.mipmaps)}else return new Promise((e,f)=>{const i=new Image();i.addEventListener("load",()=>{e(a.textureFromImageElement(i,d,b.mipmaps))}),i.addEventListener("error",function(l){f(l)});const m=window.URL.createObjectURL(c);i.src=m})}async loadTextureFromBuffer(a,c,b){const d=r[b.extension].mimeType;if(!d)throw new Error(`Unable to determine MIME type for extension "${b.extension}"`);const e=new Blob(c,{type:d});return this.loadTextureFromBlob(a,e,b)}destroy(){}}const R={};class H{constructor(a,c,b,d){this.client=a,this.options=c,this.resolve=b,this.reject=d}}const q={};let I=1;function Q(a){const c=q[a.data.id];if(!c){a.data.error&&console.error(`Texture load failed: ${a.data.error}`),console.error(`Invalid pending texture ID: ${a.data.id}`);return}delete q[a.data.id];if(a.data.error){console.error(`Texture load failed: ${a.data.error}`),c.reject(`${a.data.error}`);return}const b=c.client.textureFromTextureData(a.data,c.options.mipmaps);c.resolve(b)}class s{constructor(a){const c=R.url.replace("worker-loader.js",a);this.worker=new Worker(c),this.worker.onmessage=Q}async loadTextureFromUrl(a,c,b){const d=I++;return this.worker.postMessage({id:d,url:c,supportedFormats:a.supportedFormats(),mipmaps:b.mipmaps,extension:b.extension}),new Promise((e,f)=>{q[d]=new H(a,b,e,f)})}async loadTextureFromBlob(a,c,b){const d=await c.arrayBuffer();return this.loadTextureFromBuffer(a,d,b)}async loadTextureFromBuffer(a,c,b){const d=I++;return this.worker.postMessage({id:d,buffer:c,supportedFormats:a.supportedFormats(),mipmaps:b.mipmaps,extension:b.extension}),new Promise((e,f)=>{q[d]=new H(a,b,e,f)})}destroy(){if(this.worker){this.worker.terminate();const a=new Error("Texture loader was destroyed.");for(const c of q)c.reject(a)}}}const h=WebGLRenderingContext,C={rgb8unorm:{canGenerateMipmaps:!0,gl:{format:h.RGB,type:h.UNSIGNED_BYTE,sizedFormat:32849}},rgba8unorm:{canGenerateMipmaps:!0,gl:{format:h.RGBA,type:h.UNSIGNED_BYTE,sizedFormat:32856}},"rgb8unorm-srgb":{canGenerateMipmaps:!0,gl:{format:h.RGB,type:h.UNSIGNED_BYTE,sizedFormat:35904}},"rgba8unorm-srgb":{canGenerateMipmaps:!0,gl:{format:h.RGBA,type:h.UNSIGNED_BYTE,sizedFormat:35907}},rgb565unorm:{canGenerateMipmaps:!0,gl:{format:h.RGB,type:h.UNSIGNED_SHORT_5_6_5,sizedFormat:h.RGB565}},rgba4unorm:{canGenerateMipmaps:!0,gl:{format:h.RGBA,type:h.UNSIGNED_SHORT_4_4_4_4,sizedFormat:h.RGBA4}},rgba5551unorm:{canGenerateMipmaps:!0,gl:{format:h.RGBA,type:h.UNSIGNED_SHORT_5_5_5_1,sizedFormat:h.RGB5_A1}},bgra8unorm:{canGenerateMipmaps:!0},"bgra8unorm-srgb":{canGenerateMipmaps:!0},"bc1-rgb-unorm":{gl:{texStorage:!0,sizedFormat:33776},compressed:{blockBytes:8,blockWidth:4,blockHeight:4}},"bc2-rgba-unorm":{gl:{texStorage:!0,sizedFormat:33778},compressed:{blockBytes:16,blockWidth:4,blockHeight:4}},"bc3-rgba-unorm":{gl:{texStorage:!1,sizedFormat:33779},compressed:{blockBytes:16,blockWidth:4,blockHeight:4}},"bc7-rgba-unorm":{gl:{texStorage:!0,sizedFormat:36492},compressed:{blockBytes:16,blockWidth:4,blockHeight:4}},"etc1-rgb-unorm":{gl:{texStorage:!1,sizedFormat:36196},compressed:{blockBytes:8,blockWidth:4,blockHeight:4}},"etc2-rgba8unorm":{gl:{texStorage:!0,sizedFormat:37496},compressed:{blockBytes:16,blockWidth:4,blockHeight:4}},"astc-4x4-rgba-unorm":{gl:{texStorage:!0,sizedFormat:37808},compressed:{blockBytes:16,blockWidth:4,blockHeight:4}},"pvrtc1-4bpp-rgb-unorm":{gl:{texStorage:!1,sizedFormat:35840},compressed:{blockBytes:8,blockWidth:4,blockHeight:4}},"pvrtc1-4bpp-rgba-unorm":{gl:{texStorage:!1,sizedFormat:35842},compressed:{blockBytes:8,blockWidth:4,blockHeight:4}}};class A{constructor(a,c={}){this.texture=a,this.width=c.width||1,this.height=c.height||1,this.depth=c.depth||1,this.mipLevels=c.mipLevels||1,this.format=c.format||"rgba8unorm",this.type=c.type||"2d"}}class K{constructor(a,c,b,d=null,e={}){this.format=a,this.width=Math.max(1,c),this.height=Math.max(1,b),this.levels=[],d&&this.getLevel(0).setSlice(0,d,e)}getLevel(a,c={}){let b=this.levels[a];return b||(b=new L(this,a,c),this.levels[a]=b),b}}class L{constructor(a,c,b){this.textureData=a,this.levelIndex=c,this.width=Math.max(1,b.width||this.textureData.width>>c),this.height=Math.max(1,b.height||this.textureData.height>>c),this.slices=[]}setSlice(a,c,b={}){if(this.slices[a]!=void 0)throw new Error("Cannot define an image slice twice.");let d=b.byteOffset||0,e=b.byteLength||0,f;c instanceof ArrayBuffer?(f=c,e||(e=f.byteLength-d)):(f=c.buffer,e||(e=c.byteLength-d),d+=c.byteOffset),this.slices[a]={buffer:f,byteOffset:d,byteLength:e}}}class t{constructor(a,c){this.extensions=a,this.callback=c,this.loader=null}getLoader(){return this.loader||(this.loader=this.callback()),this.loader}}const D=[new t(z.supportedExtensions(),()=>new z()),new t(["basis"],()=>new s("basis/basis-worker.js")),new t(["ktx","ktx2"],()=>new s("ktx/ktx-worker.js")),new t(["dds"],()=>new s("dds-worker.js"))],g=Symbol("wtt/WebTextureClient"),k=Symbol("wtt/WebTextureLoaders"),u=document.createElement("a"),M=typeof createImageBitmap!=="undefined",p={extension:null,mipmaps:!0};class E{constructor(a){this[g]=a,this[k]={};for(const c of D)for(const b of c.extensions)this[k][b]=c;this[k]["*"]=D[0]}async loadTextureFromUrl(a,c){if(!this[g])throw new Error("Cannot create new textures after object has been destroyed.");const b=Object.assign({},p,c);u.href=a;if(!b.extension){const f=u.pathname.lastIndexOf(".");b.extension=f>-1?u.pathname.substring(f+1).toLowerCase():"*"}let d=this[k][b.extension];d||(d=this[k]["*"]);const e=d.getLoader();if(!e)throw new Error(`Failed to get loader for extension "${b.extension}"`);return e.loadTextureFromUrl(this[g],u.href,b)}async loadTextureFromBlob(a,c){if(!this[g])throw new Error("Cannot create new textures after object has been destroyed.");const b=Object.assign({},p,c);if(!b.extension&&b.filename){const f=b.filename.lastIndexOf(".");b.extension=f>-1?b.filename.substring(f+1).toLowerCase():null}if(!b.extension)throw new Error("Must specify an extension when creating a texture from a blob.");const d=this[k][b.extension];d||(d=this[k]["*"]);const e=d.getLoader();if(!e)throw new Error(`Failed to get loader for extension "${b.extension}"`);return e.loadTextureFromBlob(this[g],a,b)}async loadTextureFromBuffer(a,c){if(!this[g])throw new Error("Cannot create new textures after object has been destroyed.");const b=Object.assign({},p,c);if(!b.extension&&b.filename){const f=b.filename.lastIndexOf(".");b.extension=f>-1?b.filename.substring(f+1).toLowerCase():null}if(!b.extension)throw new Error("Must specify an extension when creating a texture from a blob.");const d=this[k][b.extension];d||(d=this[k]["*"]);const e=d.getLoader();if(!e)throw new Error(`Failed to get loader for extension "${b.extension}"`);return e.loadTextureFromBuffer(this[g],a,b)}async loadTextureFromElement(a,c){if(!this[g])throw new Error("Cannot create new textures after object has been destroyed.");const b=Object.assign({},p,c);if(!M)return this[g].textureFromImageElement(a,"rgba8unorm",b.mipmaps);const d=await createImageBitmap(a);return this[g].textureFromImageBitmap(d,"rgba8unorm",b.mipmaps)}async loadTextureFromImageBitmap(a,c){if(!this[g])throw new Error("Cannot create new textures after object has been destroyed.");const b=Object.assign({},p,c);return this[g].textureFromImageBitmap(a,"rgba8unorm",b.mipmaps)}createTextureFromColor(a,c,b,d=1,e="rgba8unorm"){if(!this[g])throw new Error("Cannot create new textures after object has been destroyed.");if(e!="rgba8unorm"&&e!="rgba8unorm-srgb")throw new Error('createTextureFromColor only supports "rgba8unorm" and "rgba8unorm-srgb" formats');const f=new Uint8Array([a*255,c*255,b*255,d*255]);return this[g].textureFromTextureData(new K(e,1,1,f),!1)}set allowCompressedFormats(a){this[g].allowCompressedFormats=!!a}get allowCompressedFormats(){return this[g].allowCompressedFormats}destroy(){this[g]&&(this[g].destroy(),this[g]=null)}}const v=WebGLRenderingContext;function w(a){return(a&a-1)===0}function F(a,c){return Math.floor(Math.log2(Math.max(a,c)))+1}function G(a){const c=C[a];if(!c||!c.gl)throw new Error(`No matching WebGL format for "${a}"`);return c}function N(a){switch(a){case"cube":return v.TEXTURE_CUBE_MAP;case"2d":default:return v.TEXTURE_2D}}class O{constructor(a){this.gl=a,this.isWebGL2=this.gl instanceof WebGL2RenderingContext,this.allowCompressedFormats=!0,this.extensions={astc:a.getExtension("WEBGL_compressed_texture_astc"),bptc:a.getExtension("EXT_texture_compression_bptc"),etc1:a.getExtension("WEBGL_compressed_texture_etc1"),etc2:a.getExtension("WEBGL_compressed_texture_etc"),pvrtc:a.getExtension("WEBGL_compressed_texture_pvrtc"),s3tc:a.getExtension("WEBGL_compressed_texture_s3tc")},this.uncompressedFormatList=["rgb8unorm","rgba8unorm","rgb565unorm","rgba4unorm"],this.supportedFormatList=["rgb8unorm","rgba8unorm","rgb565unorm","rgba4unorm"],this.isWebGL2?(this.uncompressedFormatList.push("rgb8unorm-srgb","rgba8unorm-srgb"),this.supportedFormatList.push("rgb8unorm-srgb","rgba8unorm-srgb")):(this.extensions.srgb=a.getExtension("EXT_sRGB"),this.extensions.srgb&&(this.uncompressedFormatList.push("rgb8unorm-srgb","rgba8unorm-srgb"),this.supportedFormatList.push("rgb8unorm-srgb","rgba8unorm-srgb"))),this.extensions.astc&&this.supportedFormatList.push("astc-4x4-rgba-unorm"),this.extensions.bptc&&this.supportedFormatList.push("bc7-rgba-unorm"),this.extensions.etc1&&this.supportedFormatList.push("etc1-rgb-unorm"),this.extensions.etc2&&this.supportedFormatList.push("etc2-rgba8unorm"),this.extensions.pvrtc&&this.supportedFormatList.push("pvrtc1-4bpp-rgb-unorm","pvrtc1-4bpp-rgba-unorm"),this.extensions.s3tc&&this.supportedFormatList.push("bc1-rgb-unorm","bc2-rgba-unorm","bc3-rgba-unorm")}supportedFormats(){return this.allowCompressedFormats?this.supportedFormatList:this.uncompressedFormatList}textureFromImageBitmap(a,c,b){const d=this.gl;if(!d)throw new Error("Cannot create new textures after object has been destroyed.");!this.isWebGL2&&b&&(b=w(a.width)&&w(a.height));const e=b?F(a.width,a.height):1,f=G(c);if(f.compressed)throw new Error(`Cannot create texture from image with compressed format "${c}"`);const i=d.createTexture();return d.bindTexture(d.TEXTURE_2D,i),this.isWebGL2?(d.texStorage2D(d.TEXTURE_2D,e,f.gl.sizedFormat,a.width,a.height),d.texSubImage2D(d.TEXTURE_2D,0,0,0,f.gl.format,f.gl.type,a)):d.texImage2D(d.TEXTURE_2D,0,f.gl.format,f.gl.format,f.gl.type,a),e>1&&d.generateMipmap(d.TEXTURE_2D),new A(i,{width:a.width,height:a.height,mipLevels:e,format:c})}textureFromImageElement(a,c,b){return this.textureFromImageBitmap(a,c,b)}textureFromTextureData(a,c){const b=this.gl;if(!b)throw new Error("Cannot create new textures after object has been destroyed.");const d=G(a.format);d.compressed&&(c=!1),!this.isWebGL2&&c&&(c=w(a.width)&&w(a.height));const e=a.levels.length>1?a.levels.length:c?F(a.width,a.height):1,f=N(a.type),i=b.createTexture();b.bindTexture(f,i);const m=this.isWebGL2&&(!d.compressed||d.gl.texStorage);m&&b.texStorage2D(f,e,d.gl.sizedFormat,a.width,a.height);for(let l=0;l<a.levels.length;++l){const j=a.levels[l];for(let x=0;x<j.slices.length;++x){const n=j.slices[x],y=f==v.TEXTURE_CUBE_MAP?v.TEXTURE_CUBE_MAP_POSITIVE_X+x:f;let o;switch(a.format){case"rgb565unorm":case"rgba4unorm":case"rgba5551unorm":o=new Uint16Array(n.buffer,n.byteOffset,n.byteLength/2);break;default:o=new Uint8Array(n.buffer,n.byteOffset,n.byteLength);break}d.compressed?m?b.compressedTexSubImage2D(y,l,0,0,j.width,j.height,d.gl.sizedFormat,o):b.compressedTexImage2D(y,l,d.gl.sizedFormat,j.width,j.height,0,o):m?b.texSubImage2D(y,l,0,0,j.width,j.height,d.gl.format,d.gl.type,o):b.texImage2D(y,l,d.gl.sizedFormat,j.width,j.height,0,d.gl.format,d.gl.type,o)}}return c&&a.levels.length==1&&b.generateMipmap(f),new A(i,{width:a.width,height:a.height,depth:a.depth,mipLevels:e,format:a.format,type:a.type})}destroy(){this.gl=null}}class P extends E{constructor(a,c){super(new O(a),c)}}export{P as WebGLTextureTool};
//# sourceMappingURL=webgl-texture-tool.js.map
