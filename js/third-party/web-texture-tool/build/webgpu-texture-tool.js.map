{
  "version": 3,
  "sources": ["src/image-loader.js", "src/workers/worker-loader.js", "src/web-texture-tool-base.js", "src/webgpu-mipmap-generator.js", "src/webgpu-texture-tool.js"],
  "sourcesContent": ["// Copyright 2020 Brandon Jones\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated\n// documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in all copies or substantial portions of the\n// Software.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE\n// WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n/**\n * @file Loader which handles any image types supported directly by the browser.\n * @module ImageLoader\n */\n\nconst IMAGE_TEXTURE_EXTENSIONS = {\n  jpg: {format: 'rgb8unorm', mimeType: 'image/jpeg'},\n  jpeg: {format: 'rgb8unorm', mimeType: 'image/jpeg'},\n  png: {format: 'rgba8unorm', mimeType: 'image/png'},\n  apng: {format: 'rgba8unorm', mimeType: 'image/apng'},\n  gif: {format: 'rgba8unorm', mimeType: 'image/gif'},\n  bmp: {format: 'rgb8unorm', mimeType: 'image/bmp'},\n  webp: {format: 'rgba8unorm', mimeType: 'image/webp'},\n  ico: {format: 'rgba8unorm', mimeType: 'image/x-icon'},\n  cur: {format: 'rgba8unorm', mimeType: 'image/x-icon'},\n  svg: {format: 'rgba8unorm', mimeType: 'image/svg+xml'},\n};\nconst IMAGE_BITMAP_SUPPORTED = (typeof createImageBitmap !== 'undefined');\n\n/**\n * Loader which handles any image types supported directly by the browser.\n */\nexport class ImageLoader {\n  /**\n   * Creates a ImageTextureLoader instance.\n   * Should only be called by the WebTextureTool constructor.\n   */\n  constructor() {\n  }\n\n  /**\n   * Which file extensions this loader supports.\n   *\n   * @returns {Array<string>} - An array of the file extensions this loader supports.\n   */\n  static supportedExtensions() {\n    return Object.keys(IMAGE_TEXTURE_EXTENSIONS);\n  }\n\n  /**\n   * Load a supported file as a texture from the given URL.\n   *\n   * @param {object} client - The WebTextureClient which will upload the texture data to the GPU.\n   * @param {string} url - An absolute URL that the texture file should be loaded from.\n   * @param {object} options - Options for how the loaded texture should be handled.\n   * @returns {Promise<module:WebTextureLoader.WebTextureResult>} - The WebTextureResult obtained from passing the\n   * parsed file data to the client.\n   */\n  async loadTextureFromUrl(client, url, options) {\n    let format = IMAGE_TEXTURE_EXTENSIONS[options.extension].format;\n\n    if (client.supportedFormatList.indexOf(format) == -1) {\n      // 'rgba8unorm' must be supported by all clients\n      format = 'rgba8unorm';\n    }\n\n    if (IMAGE_BITMAP_SUPPORTED) {\n      const response = await fetch(url);\n      const imageBitmap = await createImageBitmap(await response.blob());\n      return client.textureFromImageBitmap(imageBitmap, format, options.mipmaps);\n    } else {\n      return new Promise((resolve, reject) => {\n        const imageElement = new Image();\n        imageElement.addEventListener('load', () => {\n          resolve(client.textureFromImageElement(imageElement, format, options.mipmaps));\n        });\n        imageElement.addEventListener('error', function(err) {\n          reject(err);\n        });\n        imageElement.src = url;\n      });\n    };\n  }\n\n  /**\n   * Load a supported file as a texture from the given Blob.\n   *\n   * @param {object} client - The WebTextureClient which will upload the texture data to the GPU.\n   * @param {Blob} blob - Blob containing the texture file data.\n   * @param {object} options - Options for how the loaded texture should be handled.\n   * @returns {Promise<module:WebTextureLoader.WebTextureResult>} - The WebTextureResult obtained from passing the\n   * parsed file data to the client.\n   */\n  async loadTextureFromBlob(client, blob, options) {\n    let format = IMAGE_TEXTURE_EXTENSIONS[options.extension].format;\n\n    if (client.supportedFormatList.indexOf(format) == -1) {\n      // 'rgba8unorm' must be supported by all clients\n      format = 'rgba8unorm';\n    }\n\n    if (IMAGE_BITMAP_SUPPORTED) {\n      const imageBitmap = await createImageBitmap(blob);\n      return client.textureFromImageBitmap(imageBitmap, format, options.mipmaps);\n    } else {\n      return new Promise((resolve, reject) => {\n        const imageElement = new Image();\n        imageElement.addEventListener('load', () => {\n          resolve(client.textureFromImageElement(imageElement, format, options.mipmaps));\n        });\n        imageElement.addEventListener('error', function(err) {\n          reject(err);\n        });\n        const url = window.URL.createObjectURL(blob);\n        imageElement.src = url;\n      });\n    };\n  }\n\n  /**\n   * Load a supported file as a texture from the given ArrayBuffer or ArrayBufferView.\n   *\n   * @param {object} client - The WebTextureClient which will upload the texture data to the GPU.\n   * @param {ArrayBuffer|ArrayBufferView} buffer - Buffer containing the texture file data.\n   * @param {object} options - Options for how the loaded texture should be handled.\n   * @returns {Promise<module:WebTextureLoader.WebTextureResult>} - The WebTextureResult obtained from passing the\n   * parsed file data to the client.\n   */\n  async loadTextureFromBuffer(client, buffer, options) {\n    const mimeType = IMAGE_TEXTURE_EXTENSIONS[options.extension].mimeType;\n    if (!mimeType) {\n      throw new Error(`Unable to determine MIME type for extension \"${options.extension}\"`);\n    }\n\n    const blob = new Blob(buffer, {type: mimeType});\n    return this.loadTextureFromBlob(client, blob, options);\n  }\n\n  /**\n   * Destroy this loader.\n   *\n   * @returns {void}\n   */\n  destroy() {\n    // Nothing to clean up here.\n  }\n}\n", "// Copyright 2020 Brandon Jones\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated\n// documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in all copies or substantial portions of the\n// Software.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE\n// WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n/**\n * Generic loader which handles texture loading in a worker in order to prevent blocking the main thread.\n *\n * @file Loader that operates a worker script\n * @module WorkerLoader\n */\n\n/**\n * Tracks required data for fulfilling a texture request once it has been transcoded.\n */\nclass PendingTextureRequest {\n  /**\n   * Creates a PendingTextureRequest instance.\n   *\n   * @param {object} client - The WebTextureClient that will upload the transcoded data.\n   * @param {*} options - Options passed during the texture request.\n   * @param {*} resolve - Success callback.\n   * @param {*} reject - Failure callback.\n   */\n  constructor(client, options, resolve, reject) {\n    this.client = client;\n    this.options = options;\n    this.resolve = resolve;\n    this.reject = reject;\n  }\n};\n\nconst pendingTextures = {};\nlet nextPendingTextureId = 1;\n\n/**\n * Called when the worker either finished transcoding a file or encounters an error.\n *\n * @param {object} msg - Message contents from the worker\n * @returns {void}\n */\nfunction onWorkerMessage(msg) {\n  // Find the pending texture associated with the data we just received\n  // from the worker.\n  const pendingTexture = pendingTextures[msg.data.id];\n  if (!pendingTexture) {\n    if (msg.data.error) {\n      console.error(`Texture load failed: ${msg.data.error}`);\n    }\n    console.error(`Invalid pending texture ID: ${msg.data.id}`);\n    return;\n  }\n\n  // Remove the pending texture from the waiting list.\n  delete pendingTextures[msg.data.id];\n\n  // If the worker indicated an error has occured handle it now.\n  if (msg.data.error) {\n    console.error(`Texture load failed: ${msg.data.error}`);\n    pendingTexture.reject(`${msg.data.error}`);\n    return;\n  }\n\n  // Upload the image data returned by the worker.\n  const result = pendingTexture.client.textureFromTextureData(msg.data, pendingTexture.options.mipmaps);\n  pendingTexture.resolve(result);\n}\n\n/**\n * Loader which handles Basis Universal files.\n */\nexport class WorkerLoader {\n  /**\n   * Creates a BasisLoader instance.\n   *\n   * @param {string} relativeWorkerPath - Path to the worker script to load, relative to this file.\n   */\n  constructor(relativeWorkerPath) {\n    // Load the worker script.\n    const workerPath = import.meta.url.replace('worker-loader.js', relativeWorkerPath);\n    this.worker = new Worker(workerPath);\n    this.worker.onmessage = onWorkerMessage;\n  }\n\n  /**\n   * Load a supported file as a texture from the given URL.\n   *\n   * @param {object} client - The WebTextureClient which will upload the texture data to the GPU.\n   * @param {string} url - An absolute URL that the texture file should be loaded from.\n   * @param {object} options - Options for how the loaded texture should be handled.\n   * @returns {Promise<module:WebTextureLoader.WebTextureResult>} - The WebTextureResult obtained from passing the\n   * parsed file data to the client.\n   */\n  async loadTextureFromUrl(client, url, options) {\n    const pendingTextureId = nextPendingTextureId++;\n\n    this.worker.postMessage({\n      id: pendingTextureId,\n      url: url,\n      supportedFormats: client.supportedFormats(),\n      mipmaps: options.mipmaps,\n      extension: options.extension,\n    });\n\n    return new Promise((resolve, reject) => {\n      pendingTextures[pendingTextureId] = new PendingTextureRequest(client, options, resolve, reject);\n    });\n  }\n\n  /**\n   * Load a supported file as a texture from the given Blob.\n   *\n   * @param {object} client - The WebTextureClient which will upload the texture data to the GPU.\n   * @param {Blob} blob - Blob containing the texture file data.\n   * @param {object} options - Options for how the loaded texture should be handled.\n   * @returns {Promise<module:WebTextureLoader.WebTextureResult>} - The WebTextureResult obtained from passing the\n   * parsed file data to the client.\n   */\n  async loadTextureFromBlob(client, blob, options) {\n    const buffer = await blob.arrayBuffer();\n    return this.loadTextureFromBuffer(client, buffer, options);\n  }\n\n  /**\n   * Load a supported file as a texture from the given ArrayBuffer or ArrayBufferView.\n   *\n   * @param {object} client - The WebTextureClient which will upload the texture data to the GPU.\n   * @param {ArrayBuffer|ArrayBufferView} buffer - Buffer containing the texture file data.\n   * @param {object} options - Options for how the loaded texture should be handled.\n   * @returns {Promise<module:WebTextureLoader.WebTextureResult>} - The WebTextureResult obtained from passing the\n   * parsed file data to the client.\n   */\n  async loadTextureFromBuffer(client, buffer, options) {\n    const pendingTextureId = nextPendingTextureId++;\n\n    this.worker.postMessage({\n      id: pendingTextureId,\n      buffer: buffer,\n      supportedFormats: client.supportedFormats(),\n      mipmaps: options.mipmaps,\n      extension: options.extension,\n    });\n\n    return new Promise((resolve, reject) => {\n      pendingTextures[pendingTextureId] = new PendingTextureRequest(client, options, resolve, reject);\n    });\n  }\n\n  /**\n   * Destroy this loader.\n   * Terminates the worker and rejects any outstanding textures. The loader is unusable after calling destroy().\n   *\n   * @returns {void}\n   */\n  destroy() {\n    if (this.worker) {\n      this.worker.terminate();\n\n      const destroyedError = new Error('Texture loader was destroyed.');\n      for (const pendingTexture of pendingTextures) {\n        pendingTexture.reject(destroyedError);\n      }\n    }\n  }\n}\n", "// Copyright 2020 Brandon Jones\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated\n// documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in all copies or substantial portions of the\n// Software.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE\n// WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n/**\n * This library offers a unified way of loading textures for both WebGL and WebGPU from various file formats, and in all\n * cases attempts to handle the loading as efficently as possible. Every effort made to prevent texture loading from\n * blocking the main thread, since that can often be one of the primary causes of jank during page startup or while\n * streaming in new assets.\n *\n * @file Library for loading various image sources as textures for WebGL or WebGPU\n * @module WebTextureTool\n */\n\nimport {ImageLoader} from './image-loader.js';\nimport {WorkerLoader} from './workers/worker-loader.js';\n\n// For access to WebGL enums without a context.\nconst GL = WebGLRenderingContext;\n\n/**\n * Texture Format\n *\n * @typedef {string} WebTextureFormat\n */\n\n// Additional format data used by Web Texture Tool, based off WebGPU formats.\n// WebGL equivalents given where possible.\nexport const WebTextureFormat = {\n  // Uncompressed formats\n  'rgb8unorm': {\n    canGenerateMipmaps: true,\n    gl: {format: GL.RGB, type: GL.UNSIGNED_BYTE, sizedFormat: 0x8051}, // RGB8\n  },\n  'rgba8unorm': {\n    canGenerateMipmaps: true,\n    gl: {format: GL.RGBA, type: GL.UNSIGNED_BYTE, sizedFormat: 0x8058}, // RGBA8\n  },\n  'rgb8unorm-srgb': {\n    canGenerateMipmaps: true,\n    gl: {format: GL.RGB, type: GL.UNSIGNED_BYTE, sizedFormat: 0x8C40}, // SRGB8\n  },\n  'rgba8unorm-srgb': {\n    canGenerateMipmaps: true,\n    gl: {format: GL.RGBA, type: GL.UNSIGNED_BYTE, sizedFormat: 0x8C43}, // SRGB8_ALPHA8\n  },\n  'rgb565unorm': {\n    canGenerateMipmaps: true,\n    gl: {format: GL.RGB, type: GL.UNSIGNED_SHORT_5_6_5, sizedFormat: GL.RGB565},\n  },\n  'rgba4unorm': {\n    canGenerateMipmaps: true,\n    gl: {format: GL.RGBA, type: GL.UNSIGNED_SHORT_4_4_4_4, sizedFormat: GL.RGBA4},\n  },\n  'rgba5551unorm': {\n    canGenerateMipmaps: true,\n    gl: {format: GL.RGBA, type: GL.UNSIGNED_SHORT_5_5_5_1, sizedFormat: GL.RGB5_A1},\n  },\n\n  'bgra8unorm': {canGenerateMipmaps: true}, // No WebGL equivalent\n  'bgra8unorm-srgb': {canGenerateMipmaps: true}, // No WebGL equivalent\n\n  // Compressed formats\n  // WebGL enums from http://www.khronos.org/registry/webgl/extensions/\n  'bc1-rgb-unorm': {\n    gl: {texStorage: true, sizedFormat: 0x83F0}, // COMPRESSED_RGB_S3TC_DXT1_EXT\n    compressed: {blockBytes: 8, blockWidth: 4, blockHeight: 4},\n  },\n  'bc2-rgba-unorm': {\n    gl: {texStorage: true, sizedFormat: 0x83F2}, // COMPRESSED_RGBA_S3TC_DXT3_EXT\n    compressed: {blockBytes: 16, blockWidth: 4, blockHeight: 4},\n  },\n  'bc3-rgba-unorm': {\n    gl: {texStorage: false, sizedFormat: 0x83F3}, // COMPRESSED_RGBA_S3TC_DXT5_EXT\n    compressed: {blockBytes: 16, blockWidth: 4, blockHeight: 4},\n  },\n  'bc7-rgba-unorm': {\n    gl: {texStorage: true, sizedFormat: 0x8E8C}, // COMPRESSED_RGBA_BPTC_UNORM_EXT\n    compressed: {blockBytes: 16, blockWidth: 4, blockHeight: 4},\n  },\n  'etc1-rgb-unorm': {\n    gl: {texStorage: false, sizedFormat: 0x8D64}, // COMPRESSED_RGB_ETC1_WEBGL\n    compressed: {blockBytes: 8, blockWidth: 4, blockHeight: 4},\n  },\n  'etc2-rgba8unorm': {\n    gl: {texStorage: true, sizedFormat: 0x9278}, // COMPRESSED_RGBA8_ETC2_EAC\n    compressed: {blockBytes: 16, blockWidth: 4, blockHeight: 4},\n  },\n  'astc-4x4-rgba-unorm': {\n    gl: {texStorage: true, sizedFormat: 0x93B0}, // COMPRESSED_RGBA_ASTC_4x4_KHR\n    compressed: {blockBytes: 16, blockWidth: 4, blockHeight: 4},\n  },\n  'pvrtc1-4bpp-rgb-unorm': {\n    gl: {texStorage: false, sizedFormat: 0x8C00}, // COMPRESSED_RGB_PVRTC_4BPPV1_IMG\n    compressed: {blockBytes: 8, blockWidth: 4, blockHeight: 4},\n  },\n  'pvrtc1-4bpp-rgba-unorm': {\n    gl: {texStorage: false, sizedFormat: 0x8C02}, // COMPRESSED_RGBA_PVRTC_4BPPV1_IMG\n    compressed: {blockBytes: 8, blockWidth: 4, blockHeight: 4},\n  },\n};\n\n/**\n * Texture result from calling one of the WebTextureTool methods\n *\n * @property {(module:External.WebGLTexture|module:External.GPUTexture)} texture - WebGL or WebGPU texture object.\n * @property {number} width of mip level 0 in pixels.\n * @property {number} height of mip level 0 in pixels.\n * @property {number} depth of mip level 0 in pixels.\n * @property {number} mipLevels - Number of mip levels the texture contains.\n * @property {WebTextureFormat} format - Format of the texture.\n */\nexport class WebTextureResult {\n  /**\n   * Create an instance of a WebTextureResult.\n   *\n   * @param {(module:External.WebGLTexture|module:External.GPUTexture)} texture - WebGL or WebGPU texture object.\n   * @param {number} width of mip level 0 in pixels.\n   * @param {number} height of mip level 0 in pixels.\n   * @param {number} depth of mip level 0 in pixels.\n   * @param {number} mipLevels - Number of mip levels the texture contains.\n   * @param {WebTextureFormat} format - Format of the texture.\n   */\n  constructor(texture, description = {}) {\n    this.texture = texture;\n    this.width = description.width || 1;\n    this.height = description.height || 1;\n    this.depth = description.depth || 1;\n    this.mipLevels = description.mipLevels || 1;\n    this.format = description.format || 'rgba8unorm';\n    this.type = description.type || '2d';\n  }\n}\n\nexport class WebTextureData {\n  constructor(format, width, height, imageData = null, imageDataOptions = {}) {\n    this.format = format;\n    this.width = Math.max(1, width);\n    this.height = Math.max(1, height);\n    this.levels = [];\n\n    // Optionally, data for the first image's first mip level can be passed to the constructor to handle simple cases.\n    if (imageData) {\n      this.getLevel(0).setSlice(0, imageData, imageDataOptions);\n    }\n  }\n\n  getLevel(index, options = {}) {\n    let level = this.levels[index];\n    if (!level) {\n      level = new WebTextureLevelData(this, index, options);\n      this.levels[index] = level;\n    }\n    return level;\n  }\n}\n\nclass WebTextureLevelData {\n  constructor(textureData, levelIndex, options) {\n    this.textureData = textureData;\n    this.levelIndex = levelIndex;\n    this.width = Math.max(1, options.width || this.textureData.width >> levelIndex);\n    this.height = Math.max(1, options.height || this.textureData.height >> levelIndex);\n    this.slices = [];\n  }\n\n  setSlice(index, bufferOrTypedArray, options = {}) {\n    if (this.slices[index] != undefined) {\n      throw new Error('Cannot define an image slice twice.');\n    }\n\n    let byteOffset = options.byteOffset || 0;\n    let byteLength = options.byteLength || 0;\n\n    let buffer;\n    if (bufferOrTypedArray instanceof ArrayBuffer) {\n      buffer = bufferOrTypedArray;\n      if (!byteLength) {\n        byteLength = buffer.byteLength - byteOffset;\n      }\n    } else {\n      buffer = bufferOrTypedArray.buffer;\n      if (!byteLength) {\n        byteLength = bufferOrTypedArray.byteLength - byteOffset;\n      }\n      byteOffset += bufferOrTypedArray.byteOffset;\n    }\n\n    this.slices[index] = {\n      buffer,\n      byteOffset,\n      byteLength,\n    };\n  }\n}\n\n/**\n * Associates a set of extensions with a specifc loader.\n */\nclass ExtensionHandler {\n  /**\n   * Creates an ExtensionHandler.\n   *\n   * @param {Array<string>} extensions - List of extensions that this loader can handle.\n   * @param {Function} callback - Callback which returns an instance of the loader.\n   */\n  constructor(extensions, callback) {\n    this.extensions = extensions;\n    this.callback = callback;\n    this.loader = null;\n  }\n\n  /**\n   * Gets the loader associated with this extension set. Creates an instance by calling the callback if one hasn't been\n   * instantiated previously.\n   *\n   * @returns {object} Texture Loader instance.\n   */\n  getLoader() {\n    if (!this.loader) {\n      this.loader = this.callback();\n    }\n    return this.loader;\n  }\n}\n\nconst EXTENSION_HANDLERS = [\n  new ExtensionHandler(ImageLoader.supportedExtensions(), () => new ImageLoader()),\n  new ExtensionHandler(['basis'], () => new WorkerLoader('basis/basis-worker.js')),\n  new ExtensionHandler(['ktx', 'ktx2'], () => new WorkerLoader('ktx/ktx-worker.js')),\n  new ExtensionHandler(['dds'], () => new WorkerLoader('dds-worker.js')),\n];\n\nconst CLIENT = Symbol('wtt/WebTextureClient');\nconst LOADERS = Symbol('wtt/WebTextureLoaders');\n\nconst TMP_ANCHOR = document.createElement('a');\nconst IMAGE_BITMAP_SUPPORTED = (typeof createImageBitmap !== 'undefined');\n\nconst DEFAULT_URL_OPTIONS = {\n  extension: null,\n  mipmaps: true,\n};\n\n/**\n * Base texture tool class.\n * Must not be used directly, create an instance of WebGLTextureTool or WebGPUTextureTool instead.\n */\nexport class WebTextureTool {\n  /**\n   * WebTextureTool constructor. Must not be called by applications directly.\n   * Create an instance of WebGLTextureTool or WebGPUTextureTool as needed instead.\n   *\n   * @param {object} client - The WebTextureClient which will upload the texture data to the GPU.\n   */\n  constructor(client) {\n    this[CLIENT] = client;\n    this[LOADERS] = {};\n\n    // Map every available extension to it's associated handler\n    for (const extensionHandler of EXTENSION_HANDLERS) {\n      for (const extension of extensionHandler.extensions) {\n        this[LOADERS][extension] = extensionHandler;\n      }\n    }\n\n    // Register one last \"fallback\" extension. Anything that we receive that has an unrecognized extension will try to\n    // load with the ImageTextureLoader.\n    this[LOADERS]['*'] = EXTENSION_HANDLERS[0];\n  }\n\n  /** Loads a texture from the given URL\n   *\n   * @param {string} url - URL of the file to load.\n   * @param {object} textureOptions - Options for how the loaded texture should be handled.\n   * @returns {Promise<WebTextureResult>} - Promise which resolves to the completed WebTextureResult.\n   */\n  async loadTextureFromUrl(url, textureOptions) {\n    if (!this[CLIENT]) {\n      throw new Error('Cannot create new textures after object has been destroyed.');\n    }\n\n    const options = Object.assign({}, DEFAULT_URL_OPTIONS, textureOptions);\n\n    // Use this to resolve to a full URL.\n    TMP_ANCHOR.href = url;\n\n    // If an explicit extension wasn't provided, examine the URL to determine one.\n    if (!options.extension) {\n      // Isolate just the pathname from the given URL, then split the extension off of that.\n      const extIndex = TMP_ANCHOR.pathname.lastIndexOf('.');\n      options.extension = extIndex > -1 ? TMP_ANCHOR.pathname.substring(extIndex+1).toLowerCase() : '*';\n    }\n\n    let extensionHandler = this[LOADERS][options.extension];\n    if (!extensionHandler) {\n      extensionHandler = this[LOADERS]['*'];\n    }\n\n    // Get the appropriate loader for the extension. Will instantiate the loader instance the first time it's\n    // used.\n    const loader = extensionHandler.getLoader();\n    if (!loader) {\n      throw new Error(`Failed to get loader for extension \"${options.extension}\"`);\n    }\n\n    return loader.loadTextureFromUrl(this[CLIENT], TMP_ANCHOR.href, options);\n  }\n\n  /** Loads a texture from the given blob\n   *\n   * @param {Blob} blob - Blob containing the texture file data.\n   * @param {object} textureOptions - Options for how the loaded texture should be handled.\n   * @returns {Promise<WebTextureResult>} - Promise which resolves to the completed WebTextureResult.\n   */\n  async loadTextureFromBlob(blob, textureOptions) {\n    if (!this[CLIENT]) {\n      throw new Error('Cannot create new textures after object has been destroyed.');\n    }\n\n    const options = Object.assign({}, DEFAULT_URL_OPTIONS, textureOptions);\n\n    if (!options.extension && options.filename) {\n      const extIndex = options.filename.lastIndexOf('.');\n      options.extension = extIndex > -1 ? options.filename.substring(extIndex+1).toLowerCase() : null;\n    }\n\n    if (!options.extension) {\n      throw new Error('Must specify an extension when creating a texture from a blob.');\n    }\n\n    const extensionHandler = this[LOADERS][options.extension];\n    if (!extensionHandler) {\n      extensionHandler = this[LOADERS]['*'];\n    }\n\n    // Get the appropriate loader for the extension. Will instantiate the loader instance the first time it's\n    // used.\n    const loader = extensionHandler.getLoader();\n    if (!loader) {\n      throw new Error(`Failed to get loader for extension \"${options.extension}\"`);\n    }\n\n    return loader.loadTextureFromBlob(this[CLIENT], blob, options);\n  }\n\n  /** Loads a texture from the given blob\n   *\n   * @param {ArrayBuffer|ArrayBufferView} buffer - Buffer containing the texture file data.\n   * @param {object} textureOptions - Options for how the loaded texture should be handled.\n   * @returns {Promise<WebTextureResult>} - Promise which resolves to the completed WebTextureResult.\n   */\n  async loadTextureFromBuffer(buffer, textureOptions) {\n    if (!this[CLIENT]) {\n      throw new Error('Cannot create new textures after object has been destroyed.');\n    }\n\n    const options = Object.assign({}, DEFAULT_URL_OPTIONS, textureOptions);\n\n    if (!options.extension && options.filename) {\n      const extIndex = options.filename.lastIndexOf('.');\n      options.extension = extIndex > -1 ? options.filename.substring(extIndex+1).toLowerCase() : null;\n    }\n\n    if (!options.extension) {\n      throw new Error('Must specify an extension when creating a texture from a blob.');\n    }\n\n    const extensionHandler = this[LOADERS][options.extension];\n    if (!extensionHandler) {\n      extensionHandler = this[LOADERS]['*'];\n    }\n\n    // Get the appropriate loader for the extension. Will instantiate the loader instance the first time it's\n    // used.\n    const loader = extensionHandler.getLoader();\n    if (!loader) {\n      throw new Error(`Failed to get loader for extension \"${options.extension}\"`);\n    }\n\n    return loader.loadTextureFromBuffer(this[CLIENT], buffer, options);\n  }\n\n  /** Loads a texture from the given image element.\n   *\n   * @param {Element} element - HTML element (img, canvas, video, etc) to load as a texture.\n   * @param {object} textureOptions - Options for how the loaded texture should be handled.\n   * @returns {Promise<WebTextureResult>} - Promise which resolves to the completed WebTextureResult.\n   */\n  async loadTextureFromElement(element, textureOptions) {\n    if (!this[CLIENT]) {\n      throw new Error('Cannot create new textures after object has been destroyed.');\n    }\n\n    const options = Object.assign({}, DEFAULT_URL_OPTIONS, textureOptions);\n\n    if (!IMAGE_BITMAP_SUPPORTED) {\n      return this[CLIENT].textureFromImageElement(element, 'rgba8unorm', options.mipmaps);\n    }\n    const imageBitmap = await createImageBitmap(element);\n    return this[CLIENT].textureFromImageBitmap(imageBitmap, 'rgba8unorm', options.mipmaps);\n  }\n\n  /** Loads a texture from the given image bitmap.\n   *\n   * @param {ImageBitmap} imageBitmap - Image bitmap to load as a texture.\n   * @param {object} textureOptions - Options for how the loaded texture should be handled.\n   * @returns {Promise<WebTextureResult>} - Promise which resolves to the completed WebTextureResult.\n   */\n  async loadTextureFromImageBitmap(imageBitmap, textureOptions) {\n    if (!this[CLIENT]) {\n      throw new Error('Cannot create new textures after object has been destroyed.');\n    }\n\n    const options = Object.assign({}, DEFAULT_URL_OPTIONS, textureOptions);\n    return this[CLIENT].textureFromImageBitmap(imageBitmap, 'rgba8unorm', options.mipmaps);\n  }\n\n  /**\n   * Creates a 1x1 texture with the specified color.\n   *\n   * @param {number} r - Red channel value\n   * @param {number} g - Green channel value\n   * @param {number} b - Blue channel value\n   * @param {number} [a=1.0] - Alpha channel value\n   * @param {WebTextureFormat} [format='rgba8unorm'] - Format to create the texture with\n   * @returns {WebTextureResult} - Completed WebTextureResult\n   */\n  createTextureFromColor(r, g, b, a = 1.0, format = 'rgba8unorm') {\n    if (!this[CLIENT]) {\n      throw new Error('Cannot create new textures after object has been destroyed.');\n    }\n    if (format != 'rgba8unorm' && format != 'rgba8unorm-srgb') {\n      throw new Error('createTextureFromColor only supports \"rgba8unorm\" and \"rgba8unorm-srgb\" formats');\n    }\n    const data = new Uint8Array([r * 255, g * 255, b * 255, a * 255]);\n    return this[CLIENT].textureFromTextureData(new WebTextureData(format, 1, 1, data), false);\n  }\n\n  /**\n   * Sets whether or not compressed formats should be loaded.\n   * If `false` and a compressed texture can be transcoded to an uncompressed format it will be, otherwise it will be\n   * rejected.\n   *\n   * @param {boolean} value - `true` if compressed formats should be loaded.\n   */\n  set allowCompressedFormats(value) {\n    this[CLIENT].allowCompressedFormats = !!value;\n  }\n\n  /**\n   * Returns whether or not compressed formats should be loaded.\n   *\n   * @returns {boolean} `true` if compressed formats should be loaded.\n   */\n  get allowCompressedFormats() {\n    return this[CLIENT].allowCompressedFormats;\n  }\n\n  /**\n   * Destroys the texture tool and stops any in-progress texture loads that have been started.\n   *\n   * @returns {void}\n   */\n  destroy() {\n    if (this[CLIENT]) {\n      this[CLIENT].destroy();\n      this[CLIENT] = null;\n\n      // TODO: Should this happen?\n      // Would have to make sure every instance had it's own copies of the loaders.\n      // Shut down every loader that this class has initialized.\n      /*\n      for (const extensionHandler of this[LOADERS]) { // Doesn't work\n        if (extensionHandler.loader) {\n          extensionHandler.loader.destroy();\n          extensionHandler.loader = null;\n        }\n      }\n      */\n    }\n  }\n}\n", "// Copyright 2020 Brandon Jones\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated\n// documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in all copies or substantial portions of the\n// Software.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE\n// WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.s\n\nexport class WebGPUMipmapGenerator {\n  constructor(device) {\n    this.device = device;\n    this.sampler = device.createSampler({minFilter: 'linear'});\n    // We'll need a new pipeline for every texture format used.\n    this.pipelines = {};\n  }\n\n  getMipmapPipeline(format) {\n    let pipeline = this.pipelines[format];\n    if (!pipeline) {\n      // Shaders are shared between all pipelines, so only create once.\n      if (!this.mipmapVertexShaderModule || !this.mipmapFragmentShaderModule) {\n        this.mipmapVertexShaderModule = this.device.createShaderModule({\n          code: `\n            var<private> pos : array<vec2<f32>, 4> = array<vec2<f32>, 4>(\n              vec2<f32>(-1.0, 1.0), vec2<f32>(1.0, 1.0),\n              vec2<f32>(-1.0, -1.0), vec2<f32>(1.0, -1.0));\n            var<private> tex : array<vec2<f32>, 4> = array<vec2<f32>, 4>(\n              vec2<f32>(0.0, 0.0), vec2<f32>(1.0, 0.0),\n              vec2<f32>(0.0, 1.0), vec2<f32>(1.0, 1.0));\n\n            [[builtin(position)]] var<out> outPosition : vec4<f32>;\n            [[builtin(vertex_idx)]] var<in> vertexIndex : i32;\n\n            [[location(0)]] var<out> vTex : vec2<f32>;\n\n            [[stage(vertex)]]\n            fn main() -> void {\n              vTex = tex[vertexIndex];\n              outPosition = vec4<f32>(pos[vertexIndex], 0.0, 1.0);\n              return;\n            }\n          `,\n        });\n\n        this.mipmapFragmentShaderModule = this.device.createShaderModule({\n          code: `\n            [[binding(0), set(0)]] var<uniform_constant> imgSampler : sampler;\n            [[binding(1), set(0)]] var<uniform_constant> img : texture_sampled_2d<f32>;\n\n            [[location(0)]] var<in> vTex : vec2<f32>;\n            [[location(0)]] var<out> outColor : vec4<f32>;\n\n            [[stage(fragment)]]\n            fn main() -> void {\n              outColor = textureSample(img, imgSampler, vTex);\n              return;\n            }\n          `,\n        });\n      }\n\n      pipeline = this.device.createRenderPipeline({\n        vertexStage: {\n          module: this.mipmapVertexShaderModule,\n          entryPoint: 'main',\n        },\n        fragmentStage: {\n          module: this.mipmapFragmentShaderModule,\n          entryPoint: 'main',\n        },\n        primitiveTopology: 'triangle-strip',\n        vertexState: {\n          indexFormat: 'uint32',\n        },\n        colorStates: [{format}],\n      });\n      this.pipelines[format] = pipeline;\n    }\n    return pipeline;\n  }\n\n  /**\n   * Generates mipmaps for the given GPUTexture from the data in level 0.\n   *\n   * @param {module:External.GPUTexture} texture - Texture to generate mipmaps for.\n   * @param {object} textureDescriptor - GPUTextureDescriptor the texture was created with.\n   * @returns {module:External.GPUTexture} - The originally passed texture\n   */\n  generateMipmap(texture, textureDescriptor) {\n    // TODO: Does this need to handle sRGB formats differently?\n    const pipeline = this.getMipmapPipeline(textureDescriptor.format);\n\n    if (textureDescriptor.dimension == '3d' || textureDescriptor.dimension == '1d') {\n      throw new Error('Generating mipmaps for non-2d textures is currently unsupported!');\n    }\n\n    let mipTexture = texture;\n    const arrayLayerCount = textureDescriptor.size.depth || 1; // Only valid for 2D textures.\n\n    // If the texture was created with OUTPUT_ATTACHMENT usage we can render directly between mip levels.\n    const renderToSource = textureDescriptor.usage & GPUTextureUsage.OUTPUT_ATTACHMENT;\n    if (!renderToSource) {\n      // Otherwise we have to use a separate texture to render into. It can be one mip level smaller than the source\n      // texture, since we already have the top level.\n      const mipTextureDescriptor = {\n        size: {\n          width: Math.ceil(textureDescriptor.size.width / 2),\n          height: Math.ceil(textureDescriptor.size.height / 2),\n          depth: arrayLayerCount,\n        },\n        format: textureDescriptor.format,\n        usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.SAMPLED | GPUTextureUsage.OUTPUT_ATTACHMENT,\n        mipLevelCount: textureDescriptor.mipLevelCount - 1,\n      };\n      mipTexture = this.device.createTexture(mipTextureDescriptor);\n    }\n\n    const commandEncoder = this.device.createCommandEncoder({});\n    // TODO: Consider making this static.\n    const bindGroupLayout = pipeline.getBindGroupLayout(0);\n\n    for (let arrayLayer = 0; arrayLayer < arrayLayerCount; ++arrayLayer) {\n      let srcView = texture.createView({\n        baseMipLevel: 0,\n        mipLevelCount: 1,\n        dimension: '2d',\n        baseArrayLayer: arrayLayer,\n        arrayLayerCount: 1,\n      });\n\n      let dstMipLevel = renderToSource ? 1 : 0;\n      for (let i = 1; i < textureDescriptor.mipLevelCount; ++i) {\n        const dstView = mipTexture.createView({\n          baseMipLevel: dstMipLevel++,\n          mipLevelCount: 1,\n          dimension: '2d',\n          baseArrayLayer: arrayLayer,\n          arrayLayerCount: 1,\n        });\n\n        const passEncoder = commandEncoder.beginRenderPass({\n          colorAttachments: [{\n            attachment: dstView,\n            loadValue: [0, 0, 0, 0],\n          }],\n        });\n\n        const bindGroup = this.device.createBindGroup({\n          layout: bindGroupLayout,\n          entries: [{\n            binding: 0,\n            resource: this.sampler,\n          }, {\n            binding: 1,\n            resource: srcView,\n          }],\n        });\n\n        passEncoder.setPipeline(pipeline);\n        passEncoder.setBindGroup(0, bindGroup);\n        passEncoder.draw(4, 1, 0, 0);\n        passEncoder.endPass();\n\n        srcView = dstView;\n      }\n    }\n\n    // If we didn't render to the source texture, finish by copying the mip results from the temporary mipmap texture\n    // to the source.\n    if (!renderToSource) {\n      const mipLevelSize = {\n        width: Math.ceil(textureDescriptor.size.width / 2),\n        height: Math.ceil(textureDescriptor.size.height / 2),\n        depth: arrayLayerCount,\n      };\n\n      // TODO: This should use textureDescriptor.mipLevelCount isntead of textureDescriptor.mipLevelCount-1, but for\n      // some reason it's telling me that I'm \"touching outside the texture\" if I do that.\n      for (let i = 1; i < textureDescriptor.mipLevelCount-1; ++i) {\n        commandEncoder.copyTextureToTexture({\n          texture: mipTexture,\n          mipLevel: i-1,\n        }, {\n          texture: texture,\n          mipLevel: i,\n        }, mipLevelSize);\n\n        mipLevelSize.width = Math.ceil(mipLevelSize.width / 2);\n        mipLevelSize.height = Math.ceil(mipLevelSize.height / 2);\n      }\n    }\n\n    this.device.defaultQueue.submit([commandEncoder.finish()]);\n\n    if (!renderToSource) {\n      mipTexture.destroy();\n    }\n\n    return texture;\n  }\n}\n", "// Copyright 2020 Brandon Jones\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated\n// documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in all copies or substantial portions of the\n// Software.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE\n// WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n/**\n * Supports loading textures for WebGPU, as well as providing common utilities that are not part of the core WebGPU API\n * such as mipmap generation.\n *\n * @file WebGPU client for the Web Texture Tool\n * @module WebGPUTextureTool\n */\n\nimport {WebTextureFormat, WebTextureTool, WebTextureResult} from './web-texture-tool-base.js';\nimport {WebGPUMipmapGenerator} from './webgpu-mipmap-generator.js';\n\nconst IMAGE_BITMAP_SUPPORTED = (typeof createImageBitmap !== 'undefined');\n\nconst EXTENSION_FORMATS = {\n  'texture-compression-bc': [\n    'bc1-rgba-unorm',\n    'bc2-rgba-unorm',\n    'bc3-rgba-unorm',\n    'bc7-rgba-unorm',\n  ],\n  'textureCompressionBC': [ // Non-standard\n    'bc1-rgba-unorm',\n    'bc2-rgba-unorm',\n    'bc3-rgba-unorm',\n    'bc7-rgba-unorm',\n  ],\n};\n\n/**\n * Determines the number of mip levels needed for a full mip chain given the width and height of texture level 0.\n *\n * @param {number} width of texture level 0.\n * @param {number} height of texture level 0.\n * @returns {number} Ideal number of mip levels.\n */\nfunction calculateMipLevels(width, height) {\n  return Math.floor(Math.log2(Math.max(width, height))) + 1;\n}\n\n/**\n * Texture Client that interfaces with WebGPU.\n */\nclass WebGPUTextureClient {\n  /**\n   * Creates a WebTextureClient instance which uses WebGPU.\n   * Should not be called outside of the WebGLTextureTool constructor.\n   *\n   * @param {module:External.GPUDevice} device - WebGPU device to use.\n   */\n  constructor(device) {\n    this.device = device;\n    this.allowCompressedFormats = true;\n\n    this.uncompressedFormatList = [\n      'rgba8unorm',\n      'rgba8unorm-srgb',\n      'bgra8unorm',\n      'bgra8unorm-srgb',\n    ];\n\n    this.supportedFormatList = [\n      'rgba8unorm',\n      'rgba8unorm-srgb',\n      'bgra8unorm',\n      'bgra8unorm-srgb',\n    ];\n\n    // Add any other formats that are exposed by extensions.\n    if (device.extensions) {\n      for (const extension of device.extensions) {\n        const formats = EXTENSION_FORMATS[extension];\n        if (formats) {\n          this.supportedFormatList.push(...formats);\n        }\n      }\n    }\n\n    this.mipmapGenerator = new WebGPUMipmapGenerator(device);\n  }\n\n  /**\n   * Returns a list of the WebTextureFormats that this client can support.\n   *\n   * @returns {Array<module:WebTextureTool.WebTextureFormat>} - List of supported WebTextureFormats.\n   */\n  supportedFormats() {\n    if (this.allowCompressedFormats) {\n      return this.supportedFormatList;\n    } else {\n      return this.uncompressedFormatList;\n    }\n  }\n\n  /**\n   * Creates a GPUTexture from the given ImageBitmap.\n   *\n   * @param {module:External.ImageBitmap} imageBitmap - ImageBitmap source for the texture.\n   * @param {module:WebTextureTool.WebTextureFormat} format - Format to store the texture as on the GPU. Must be an\n   * uncompressed format.\n   * @param {boolean} generateMipmaps - True if mipmaps are desired.\n   * @returns {module:WebTextureTool.WebTextureResult} - Completed texture and metadata.\n   */\n  async textureFromImageBitmap(imageBitmap, format, generateMipmaps) {\n    if (!this.device) {\n      throw new Error('Cannot create new textures after object has been destroyed.');\n    }\n    const mipLevelCount = generateMipmaps ? calculateMipLevels(imageBitmap.width, imageBitmap.height) : 1;\n\n    const usage = GPUTextureUsage.COPY_DST | GPUTextureUsage.SAMPLED;\n\n    const textureDescriptor = {\n      size: {width: imageBitmap.width, height: imageBitmap.height, depth: 1},\n      format,\n      usage,\n      mipLevelCount,\n    };\n    const texture = this.device.createTexture(textureDescriptor);\n\n    this.device.defaultQueue.copyImageBitmapToTexture({imageBitmap}, {texture}, textureDescriptor.size);\n\n    if (generateMipmaps) {\n      this.mipmapGenerator.generateMipmap(texture, textureDescriptor);\n    }\n\n    return new WebTextureResult(texture, {\n      width: imageBitmap.width,\n      height: imageBitmap.height,\n      mipLevels: mipLevelCount,\n      format: format,\n    });\n  }\n\n  /**\n   * Creates a GPUTexture from the given HTMLImageElement.\n   * Note that WebGPU cannot consume image elements directly, so this method will attempt to create an ImageBitmap and\n   * pass that to textureFromImageBitmap instead.\n   *\n   * @param {module:External.HTMLImageElement} image - image source for the texture.\n   * @param {module:WebTextureTool.WebTextureFormat} format - Format to store the texture as on the GPU. Must be an\n   * uncompressed format.\n   * @param {boolean} generateMipmaps - True if mipmaps are desired.\n   * @returns {module:WebTextureTool.WebTextureResult} - Completed texture and metadata.\n   */\n  async textureFromImageElement(image, format, generateMipmaps) {\n    if (!this.device) {\n      throw new Error('Cannot create new textures after object has been destroyed.');\n    }\n    if (!IMAGE_BITMAP_SUPPORTED) {\n      throw new Error('Must support ImageBitmap to use WebGPU. (How did you even get to this error?)');\n    }\n    const imageBitmap = await createImageBitmap(image);\n    return this.textureFromImageBitmap(imageBitmap, format, generateMipmaps);\n  }\n\n  /**\n   * Creates a GPUTexture from the given texture level data.\n   *\n   * @param {module:WebTextureTool.WebTextureData} textureData - Object containing data and layout for each image and\n   * mip level of the texture.\n   * @param {boolean} generateMipmaps - True if mipmaps generation is desired. Only applies if a single level is given\n   * and the texture format is renderable.\n   * @returns {module:WebTextureTool.WebTextureResult} - Completed texture and metadata.\n   */\n  textureFromTextureData(textureData, generateMipmaps) {\n    if (!this.device) {\n      throw new Error('Cannot create new textures after object has been destroyed.');\n    }\n\n    const wtFormat = WebTextureFormat[textureData.format];\n    if (!wtFormat) {\n      throw new Error(`Unknown format \"${textureData.format}\"`);\n    }\n\n    const blockInfo = wtFormat.compressed || {blockBytes: 4, blockWidth: 1, blockHeight: 1};\n    generateMipmaps = generateMipmaps && wtFormat.canGenerateMipmaps;\n\n    const mipLevelCount = textureData.levels.length > 1 ? textureData.levels.length :\n                            (generateMipmaps ? calculateMipLevels(textureData.width, textureData.height) : 1);\n\n    const usage = GPUTextureUsage.COPY_DST | GPUTextureUsage.SAMPLED;\n\n    const textureDescriptor = {\n      size: {\n        width: Math.ceil(textureData.width / blockInfo.blockWidth) * blockInfo.blockWidth,\n        height: Math.ceil(textureData.height / blockInfo.blockHeight) * blockInfo.blockHeight,\n        depth: textureData.depth,\n      },\n      format: textureData.format,\n      usage,\n      mipLevelCount: mipLevelCount,\n    };\n    const texture = this.device.createTexture(textureDescriptor);\n\n    for (const mipLevel of textureData.levels) {\n      const bytesPerRow = Math.ceil(mipLevel.width / blockInfo.blockWidth) * blockInfo.blockBytes;\n\n      for (const slice of mipLevel.slices) {\n        // TODO: It may be more efficient to upload the mip levels to a buffer and copy to the texture, but this makes\n        // the code significantly simpler and avoids an alignment issue I was seeing previously, so for now we'll take\n        // the easy route.\n        this.device.defaultQueue.writeTexture(\n            {\n              texture: texture,\n              mipLevel: mipLevel.levelIndex,\n              origin: {z: slice.sliceIndex},\n            },\n            slice.buffer,\n            {\n              offset: slice.byteOffset,\n              bytesPerRow,\n            },\n            { // Copy width and height must be a multiple of the format block size;\n              width: Math.ceil(mipLevel.width / blockInfo.blockWidth) * blockInfo.blockWidth,\n              height: Math.ceil(mipLevel.height / blockInfo.blockHeight) * blockInfo.blockHeight,\n              depth: 1,\n            });\n      }\n    }\n\n    if (generateMipmaps) {\n      this.mipmapGenerator.generateMipmap(texture, textureDescriptor);\n    }\n\n    return new WebTextureResult(texture, {\n      width: textureData.width,\n      height: textureData.height,\n      depth: textureData.depth,\n      mipLevels: mipLevelCount,\n      format: textureData.format,\n      type: textureData.type,\n    });\n  }\n\n  /**\n   * Destroy this client.\n   * The client is unusable after calling destroy().\n   *\n   * @returns {void}\n   */\n  destroy() {\n    this.device = null;\n  }\n}\n\n/**\n * Variant of WebTextureTool which produces WebGPU textures.\n */\nexport class WebGPUTextureTool extends WebTextureTool {\n  /**\n   * Creates a WebTextureTool instance which produces WebGPU textures.\n   *\n   * @param {module:External.GPUDevice} device - WebGPU device to create textures with.\n   * @param {object} toolOptions - Options to initialize this WebTextureTool instance with.\n   */\n  constructor(device, toolOptions) {\n    super(new WebGPUTextureClient(device), toolOptions);\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
