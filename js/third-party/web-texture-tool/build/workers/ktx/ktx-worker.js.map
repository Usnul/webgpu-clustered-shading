{
  "version": 3,
  "sources": ["src/workers/ktx/ktx-worker.js"],
  "sourcesContent": ["// Copyright 2020 Brandon Jones\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated\n// documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in all copies or substantial portions of the\n// Software.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE\n// WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n/**\n * @file Web Worker for loading/transcoding KTX files\n * @module KTXLoader\n *\n * Loads the Khronos Standard KTX2 file format (spec: http://github.khronos.org/KTX-Specification/)\n * Basis transcoding is handled by Web Assembly code in msc_transcoder_wrapper.wasm, which is maintained at\n * https://github.com/KhronosGroup/KTX-Software\n */\n\nimportScripts('../worker-util.js');\nimportScripts('libktx.js');\n\n// eslint-disable-next-line new-cap\nconst KTX_INITIALIZED = new Promise((resolve) => {\n  // Turns out this isn't a \"real\" promise, so we can't use it with await later on. Hence the wrapper promise.\n  // eslint-disable-next-line new-cap\n  LIBKTX().then(resolve);\n});\n\nconst WTT_FORMAT_MAP = {\n  // Compressed formats\n  BC1_RGB: {format: 'bc1-rgb-unorm'},\n  BC3_RGBA: {format: 'bc3-rgba-unorm'},\n  BC7_M5_RGBA: {format: 'bc7-rgba-unorm'},\n  ETC1_RGB: {format: 'etc1-rgb-unorm'},\n  ETC2_RGBA: {format: 'etc2-rgba8unorm'},\n  ASTC_4x4_RGBA: {format: 'astc-4x4-rgba-unorm'},\n  PVRTC1_4_RGB: {format: 'pvrtc1-4bpp-rgb-unorm'},\n  PVRTC1_4_RGBA: {format: 'pvrtc1-4bpp-rgba-unorm'},\n\n  // Uncompressed formats\n  RGBA32: {format: 'rgba8unorm', uncompressed: true},\n  RGB565: {format: 'rgb565unorm', uncompressed: true},\n  RGBA4444: {format: 'rgba4unorm', uncompressed: true},\n};\n\n// See http://richg42.blogspot.com/2018/05/basis-universal-gpu-texture-format.html for details.\n// ETC1 Should be the highest quality, so use when available.\n// If we don't support any appropriate compressed formats transcode to raw RGB(A) pixels. This is something of a last\n// resort, because the GPU upload will be significantly slower and take a lot more memory, but at least it prevents you\n// from needing to store a fallback JPG/PNG and the download size will still likely be smaller.\nconst alphaFormatPreference = [\n  'ETC2_RGBA', 'BC7_M5_RGBA', 'BC3_RGBA', 'ASTC_4x4_RGBA', 'PVRTC1_4_RGBA', 'RGBA32'];\n// eslint-disable-next-line no-unused-vars\nconst opaqueFormatPreference = [\n  'ETC1_RGB', 'BC7_M5_RGBA', 'BC1_RGB', 'ETC2_RGBA', 'ASTC_4x4_RGBA', 'PVRTC1_4_RGB', 'RGB565', 'RGBA32'];\n\n// TODO: There doesn't appear to be any limit on which of the many MANY VkFormats can be supported, so we'll need a\n// plan for supporting as many as we can.\nfunction vkFormatToGPUFormat(vkFormat) {\n  switch (vkFormat) {\n    case 0: // VK_FORMAT_UNDEFINED\n      throw new Error(`Cannot decode if VkFormat is VK_FORMAT_UNDEFINED`);\n    case 23: // VK_FORMAT_R8G8B8_UNORM\n      return 'rgb8unorm';\n    case 37: // VK_FORMAT_R8G8B8A8_UNORM\n      return 'rgba8unorm';\n    case 43: // VK_FORMAT_R8G8B8A8_SRGB\n      return 'rgba8unorm-srgb';\n    default:\n      throw new Error(`Unsupported VkFormat: ${vkFormat}`);\n  }\n}\n\n// TODO: Expand this list too.\nfunction glFormatToGPUFormat(glInternalFormat) {\n  switch (glInternalFormat) {\n    case 0: // GL_NONE\n      throw new Error(`Cannot decode if glInternalFormat is GL_NONE`);\n    case 0x8051: // GL_RGB8\n      return 'rgb8unorm';\n    case 0x8058: // GL_RGBA8\n      return 'rgba8unorm';\n    case 0x8C41: // SRGB8\n      return 'rgb8unorm-srgb';\n    case 0x8C43: // SRGB8_ALPHA8\n      return 'rgba8unorm-srgb';\n    default:\n      throw new Error(`Unsupported glInternalFormat: ${glInternalFormat}`);\n  }\n}\n\nfunction getTextureType(ktxTexture) {\n  if (ktxTexture.baseDepth > 1) {\n    return '3d';\n  } else if (ktxTexture.isCubemap) {\n    if (ktxTexture.isArray) {\n      return 'cube-array';\n    }\n    return 'cube';\n  } else if (ktxTexture.isArray) {\n    return '2d-array';\n  }\n  return '2d';\n}\n\nasync function parseFile(buffer, supportedFormats, mipmaps) {\n  const ktx = await KTX_INITIALIZED;\n\n  // eslint-disable-next-line new-cap\n  const ktxTexture = new ktx.ktxTexture(new Uint8Array(buffer));\n\n  let format;\n  if (ktxTexture.needsTranscoding) {\n    let transcodeFormat;\n    // eslint-disable-next-line guard-for-in\n    for (const targetFormat of alphaFormatPreference) {\n      const wttFormat = WTT_FORMAT_MAP[targetFormat];\n      if (supportedFormats.indexOf(wttFormat.format) > -1) {\n        format = wttFormat.format;\n        transcodeFormat = ktx.TranscodeTarget[targetFormat];\n        break;\n      }\n    }\n\n    if (!transcodeFormat) {\n      throw new Error('No appropriate transcode format found.');\n    }\n\n    const result = ktxTexture.transcodeBasis(transcodeFormat, 0);\n    if (result != ktx.ErrorCode.SUCCESS) {\n      throw new Error('Unable to transcode basis texture.');\n    }\n  } else {\n    if (ktxTexture.classId == 2) { // KTX2 texture\n      format = vkFormatToGPUFormat(ktxTexture.vkFormat);\n      if (supportedFormats.indexOf(format) == -1) {\n        throw new Error(`Texture stored in unsupported format: ${format}`);\n      }\n    } else if (ktxTexture.classId == 1) { // KTX texture\n      format = glFormatToGPUFormat(ktxTexture.glInternalformat);\n      if (supportedFormats.indexOf(format) == -1) {\n        throw new Error(`Texture stored in unsupported format: ${format}`);\n      }\n    }\n  }\n\n  if (!format) {\n    throw new Error('Unable to identify texture format.');\n  }\n\n  const type = getTextureType(ktxTexture);\n\n  const textureData = new WorkerTextureData({\n    format,\n    type,\n    width: ktxTexture.baseWidth,\n    height: ktxTexture.baseHeight,\n    depth: ktxTexture.baseDepth,\n  });\n\n  // Transcode each mip level of each image.\n  for (let level = 0; level < ktxTexture.numLevels; ++level) {\n    const textureLevel = textureData.getLevel(level);\n\n    for (let layer = 0; layer < ktxTexture.numLayers; ++layer) {\n      for (let face = 0; face < ktxTexture.numFaces; ++face) {\n        const sliceIndex = (layer * ktxTexture.numFaces) + face;\n        const imageData = ktxTexture.getImageData(level, layer, face);\n\n        // Copy to a new Uint8Array for transfer.\n        const levelData = new Uint8Array(imageData.byteLength);\n        levelData.set(imageData);\n        textureLevel.setSlice(sliceIndex, levelData);\n      }\n    }\n  }\n\n  ktxTexture.delete();\n\n  return textureData;\n}\n\nonmessage = createTextureMessageHandler(parseFile);\n"],
  "mappings": "AAAA,AAwBA,cAAc,qBACd,cAAc,aAGd,KAAM,GAAkB,GAAI,SAAQ,AAAC,IAGnC,SAAS,KAAK,KAGV,EAAiB,CAErB,QAAS,CAAC,OAAQ,iBAClB,SAAU,CAAC,OAAQ,kBACnB,YAAa,CAAC,OAAQ,kBACtB,SAAU,CAAC,OAAQ,kBACnB,UAAW,CAAC,OAAQ,mBACpB,cAAe,CAAC,OAAQ,uBACxB,aAAc,CAAC,OAAQ,yBACvB,cAAe,CAAC,OAAQ,0BAGxB,OAAQ,CAAC,OAAQ,aAAc,aAAc,IAC7C,OAAQ,CAAC,OAAQ,cAAe,aAAc,IAC9C,SAAU,CAAC,OAAQ,aAAc,aAAc,KAQ3C,EAAwB,CAC5B,YAAa,cAAe,WAAY,gBAAiB,gBAAiB,UAO5E,WAA6B,GAC3B,OAAQ,OACD,GACH,KAAM,IAAI,OAAM,wDACb,IACH,MAAO,gBACJ,IACH,MAAO,iBACJ,IACH,MAAO,0BAEP,KAAM,IAAI,OAAM,yBAAyB,MAK/C,WAA6B,GAC3B,OAAQ,OACD,GACH,KAAM,IAAI,OAAM,oDACb,OACH,MAAO,gBACJ,OACH,MAAO,iBACJ,OACH,MAAO,qBACJ,OACH,MAAO,0BAEP,KAAM,IAAI,OAAM,iCAAiC,MAIvD,WAAwB,GACtB,GAAI,EAAW,UAAY,EACzB,MAAO,KACF,IAAI,EAAW,UACpB,MAAI,GAAW,QACN,aAEF,OACF,GAAI,EAAW,QACpB,MAAO,WAET,MAAO,KAGT,iBAAyB,EAAQ,EAAkB,GACjD,KAAM,GAAM,KAAM,GAGZ,EAAa,GAAI,GAAI,WAAW,GAAI,YAAW,IAErD,GAAI,GACJ,GAAI,EAAW,kBACb,GAAI,GAEJ,SAAW,KAAgB,IACzB,KAAM,GAAY,EAAe,GACjC,GAAI,EAAiB,QAAQ,EAAU,QAAU,IAC/C,EAAS,EAAU,OACnB,EAAkB,EAAI,gBAAgB,GACtC,OAIJ,GAAI,CAAC,EACH,KAAM,IAAI,OAAM,0CAGlB,KAAM,GAAS,EAAW,eAAe,EAAiB,GAC1D,GAAI,GAAU,EAAI,UAAU,QAC1B,KAAM,IAAI,OAAM,8CAGd,EAAW,SAAW,GACxB,EAAS,EAAoB,EAAW,UACxC,GAAI,EAAiB,QAAQ,IAAW,GACtC,KAAM,IAAI,OAAM,yCAAyC,aAElD,EAAW,SAAW,GAC/B,EAAS,EAAoB,EAAW,kBACxC,GAAI,EAAiB,QAAQ,IAAW,GACtC,KAAM,IAAI,OAAM,yCAAyC,KAK/D,GAAI,CAAC,EACH,KAAM,IAAI,OAAM,sCAGlB,KAAM,GAAO,EAAe,GAEtB,EAAc,GAAI,mBAAkB,CACxC,SACA,OACA,MAAO,EAAW,UAClB,OAAQ,EAAW,WACnB,MAAO,EAAW,YAIpB,OAAS,GAAQ,EAAG,EAAQ,EAAW,UAAW,EAAE,GAClD,KAAM,GAAe,EAAY,SAAS,GAE1C,OAAS,GAAQ,EAAG,EAAQ,EAAW,UAAW,EAAE,EAClD,OAAS,GAAO,EAAG,EAAO,EAAW,SAAU,EAAE,GAC/C,KAAM,GAAc,EAAQ,EAAW,SAAY,EAC7C,EAAY,EAAW,aAAa,EAAO,EAAO,GAGlD,EAAY,GAAI,YAAW,EAAU,YAC3C,EAAU,IAAI,GACd,EAAa,SAAS,EAAY,IAKxC,SAAW,SAEJ,EAGT,UAAY,4BAA4B",
  "names": []
}
