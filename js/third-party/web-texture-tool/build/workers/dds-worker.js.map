{
  "version": 3,
  "sources": ["src/workers/dds-worker.js"],
  "sourcesContent": ["// Copyright 2020 Brandon Jones\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated\n// documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in all copies or substantial portions of the\n// Software.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE\n// WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n/**\n * @file Web Worker for loading/transcoding DirectDraw Surface (DDS) texture files\n * @module DDSWorker\n */\n\nimportScripts('./worker-util.js');\n\n// All values and structures referenced from:\n// http://msdn.microsoft.com/en-us/library/bb943991.aspx/\nconst DDS_MAGIC = 0x20534444;\n\nconst DDSD_CAPS = 0x1;\nconst DDSD_HEIGHT = 0x2;\nconst DDSD_WIDTH = 0x4;\nconst DDSD_PITCH = 0x8;\nconst DDSD_PIXELFORMAT = 0x1000;\nconst DDSD_MIPMAPCOUNT = 0x20000;\nconst DDSD_LINEARSIZE = 0x80000;\nconst DDSD_DEPTH = 0x800000;\n\nconst DDSCAPS_COMPLEX = 0x8;\nconst DDSCAPS_MIPMAP = 0x400000;\nconst DDSCAPS_TEXTURE = 0x1000;\n\nconst DDSCAPS2_CUBEMAP = 0x200;\nconst DDSCAPS2_CUBEMAP_POSITIVEX = 0x400;\nconst DDSCAPS2_CUBEMAP_NEGATIVEX = 0x800;\nconst DDSCAPS2_CUBEMAP_POSITIVEY = 0x1000;\nconst DDSCAPS2_CUBEMAP_NEGATIVEY = 0x2000;\nconst DDSCAPS2_CUBEMAP_POSITIVEZ = 0x4000;\nconst DDSCAPS2_CUBEMAP_NEGATIVEZ = 0x8000;\nconst DDSCAPS2_VOLUME = 0x200000;\n\nconst DDPF_ALPHAPIXELS = 0x1;\nconst DDPF_ALPHA = 0x2;\nconst DDPF_FOURCC = 0x4;\nconst DDPF_RGB = 0x40;\nconst DDPF_YUV = 0x200;\nconst DDPF_LUMINANCE = 0x20000;\n\n/**\n * @param value\n */\nfunction fourCCToInt32(value) {\n  return value.charCodeAt(0) +\n        (value.charCodeAt(1) << 8) +\n        (value.charCodeAt(2) << 16) +\n        (value.charCodeAt(3) << 24);\n}\n\n/**\n * @param value\n */\nfunction int32ToFourCC(value) {\n  return String.fromCharCode(\n      value & 0xff,\n      (value >> 8) & 0xff,\n      (value >> 16) & 0xff,\n      (value >> 24) & 0xff,\n  );\n}\n\nconst FOURCC_DXT1 = fourCCToInt32('DXT1');\nconst FOURCC_DXT3 = fourCCToInt32('DXT3');\nconst FOURCC_DXT5 = fourCCToInt32('DXT5');\nconst FOURCC_ETC1 = fourCCToInt32('ETC1');\n\nconst headerLengthInt = 31; // The header length in 32 bit ints\n\n// Offsets into the header array\nconst off_magic = 0;\n\nconst off_size = 1;\nconst off_flags = 2;\nconst off_height = 3;\nconst off_width = 4;\n\nconst off_mipmapCount = 7;\n\nconst off_pfFlags = 20;\nconst off_pfFourCC = 21;\nconst off_RGBBitCount = 22;\nconst off_RBitMask = 23;\nconst off_GBitMask = 24;\nconst off_BBitMask = 25;\nconst off_ABitMask = 26;\n\n// Little reminder for myself where the above values come from\n/* DDS_PIXELFORMAT {\n    int32 dwSize; // offset: 19\n    int32 dwFlags;\n    char[4] dwFourCC;\n    int32 dwRGBBitCount;\n    int32 dwRBitMask;\n    int32 dwGBitMask;\n    int32 dwBBitMask;\n    int32 dwABitMask; // offset: 26\n};\n\nDDS_HEADER {\n    int32 dwSize; // 1\n    int32 dwFlags;\n    int32 dwHeight;\n    int32 dwWidth;\n    int32 dwPitchOrLinearSize;\n    int32 dwDepth;\n    int32 dwMipMapCount; // offset: 7\n    int32[11] dwReserved1;\n    DDS_PIXELFORMAT ddspf; // offset 19\n    int32 dwCaps; // offset: 27\n    int32 dwCaps2;\n    int32 dwCaps3;\n    int32 dwCaps4;\n    int32 dwReserved2; // offset 31\n};*/\n\n/**\n * Transcodes DXT into RGB565.\n * Optimizations:\n * 1. Use integer math to compute c2 and c3 instead of floating point\n * math.  Specifically:\n * c2 = 5/8 * c0 + 3/8 * c1\n * c3 = 3/8 * c0 + 5/8 * c1\n * This is about a 40% performance improvement.  It also appears to\n * match what hardware DXT decoders do, as the colors produced\n * by this integer math match what hardware produces, while the\n * floating point in dxtToRgb565Unoptimized() produce slightly\n * different colors (for one GPU this was tested on).\n * 2. Unroll the inner loop.  Another ~10% improvement.\n * 3. Compute r0, g0, b0, r1, g1, b1 only once instead of twice.\n * Another 10% improvement.\n * 4. Use a Uint16Array instead of a Uint8Array.  Another 10% improvement.\n *\n * @author Evan Parker\n * @param {Uint16Array} src The src DXT bits as a Uint16Array.\n * @param {number} srcByteOffset\n * @param src16Offset\n * @param {number} width\n * @param {number} height\n * @returns {Uint16Array} dst\n */\nfunction dxtToRgb565(src, src16Offset, width, height) {\n  const c = new Uint16Array(4);\n  const dst = new Uint16Array(width * height);\n  const nWords = (width * height) / 4;\n  let m = 0;\n  let dstI = 0;\n  let i = 0;\n  let rb0 = 0; let g0 = 0; let rb1 = 0; let g1 = 0;\n\n  const blockWidth = width / 4;\n  const blockHeight = height / 4;\n  for (let blockY = 0; blockY < blockHeight; blockY++) {\n    for (let blockX = 0; blockX < blockWidth; blockX++) {\n      i = src16Offset + 4 * (blockY * blockWidth + blockX);\n      c[0] = src[i];\n      c[1] = src[i + 1];\n      rb0 = c[0] & 0xf81f;\n      g0 = c[0] & 0x7e0;\n      rb1 = c[1] & 0xf81f;\n      g1 = c[1] & 0x7e0;\n      // Interpolate between c0 and c1 to get c2 and c3.\n      // Note that we approximate 1/3 as 3/8 and 2/3 as 5/8 for\n      // speed. This also appears to be what the hardware DXT\n      // decoder in many GPUs does :)\n      c[2] = (((5 * rb0 + 3 * rb1) >> 3) & 0xf81f) |\n                (((5 * g0 + 3 * g1) >> 3) & 0x7e0);\n      c[3] = (((5 * rb1 + 3 * rb0) >> 3) & 0xf81f) |\n                (((5 * g1 + 3 * g0) >> 3) & 0x7e0);\n      m = src[i + 2];\n      dstI = (blockY * 4) * width + blockX * 4;\n      dst[dstI] = c[m & 0x3];\n      dst[dstI + 1] = c[(m >> 2) & 0x3];\n      dst[dstI + 2] = c[(m >> 4) & 0x3];\n      dst[dstI + 3] = c[(m >> 6) & 0x3];\n      dstI += width;\n      dst[dstI] = c[(m >> 8) & 0x3];\n      dst[dstI + 1] = c[(m >> 10) & 0x3];\n      dst[dstI + 2] = c[(m >> 12) & 0x3];\n      dst[dstI + 3] = c[(m >> 14)];\n      m = src[i + 3];\n      dstI += width;\n      dst[dstI] = c[m & 0x3];\n      dst[dstI + 1] = c[(m >> 2) & 0x3];\n      dst[dstI + 2] = c[(m >> 4) & 0x3];\n      dst[dstI + 3] = c[(m >> 6) & 0x3];\n      dstI += width;\n      dst[dstI] = c[(m >> 8) & 0x3];\n      dst[dstI + 1] = c[(m >> 10) & 0x3];\n      dst[dstI + 2] = c[(m >> 12) & 0x3];\n      dst[dstI + 3] = c[(m >> 14)];\n    }\n  }\n  return dst;\n}\n\n/**\n * Parses a DDS file from the given arrayBuffer and uploads it into the currently bound texture\n *\n * @param {WebGLRenderingContext} gl WebGL rendering context\n * @param {WebGLCompressedTextureS3TC} ext WEBGL_compressed_texture_s3tc extension object\n * @param {TypedArray} buffer Array Buffer containing the DDS files data\n * @param {boolean} [loadMipmaps] If false only the top mipmap level will be loaded, otherwise all available mipmaps will be uploaded\n *\n * @returns {number} Number of mipmaps uploaded, 0 if there was an error\n */\nfunction parseFile(buffer, supportedFormats, mipmaps) {\n  const header = new Int32Array(buffer, 0, headerLengthInt);\n\n  if(header[off_magic] != DDS_MAGIC) {\n    throw new Error('Invalid magic number in DDS header');\n  }\n\n  if(!header[off_pfFlags] & DDPF_FOURCC) {\n    throw new Error('Unsupported format, must contain a FourCC code');\n  }\n\n  const fourCC = header[off_pfFourCC];\n  let blockBytes = 0;\n  let bytesPerPixel = 0;\n  let internalFormat = 'unknown';\n  switch(fourCC) {\n    case FOURCC_DXT1:\n      blockBytes = 8;\n      internalFormat = 'bc1-rgb-unorm';\n      break;\n\n    case FOURCC_DXT3:\n      blockBytes = 16;\n      internalFormat = 'bc2-rgba-unorm';\n      break;\n\n    case FOURCC_DXT5:\n      blockBytes = 16;\n      internalFormat = 'bc3-rgba-unorm';\n      break;\n\n    case FOURCC_ETC1:\n      blockBytes = 8;\n      internalFormat = 'etc1-rgb-unorm';\n      break;\n\n    default: {\n      const bitCount = header[off_RGBBitCount];\n      const rBitMask = header[off_RBitMask];\n      const gBitMask = header[off_GBitMask];\n      const bBitMask = header[off_BBitMask];\n      const aBitMask = header[off_ABitMask];\n\n      if (bitCount === 32) {\n        if (rBitMask & 0xff &&\n            gBitMask & 0xff00 &&\n            bBitMask & 0xff0000) {\n          internalFormat = 'rgba8unorm';\n          bytesPerPixel = 4;\n        } else if (rBitMask & 0xff0000 &&\n                   gBitMask & 0xff00 &&\n                   bBitMask & 0xff) {\n          internalFormat = 'bgra8unorm';\n          bytesPerPixel = 4;\n        }\n      } else if (bitCount === 24) {\n        if (rBitMask & 0xff0000 &&\n            gBitMask & 0xff00 &&\n            bBitMask & 0xff) {\n          internalFormat = 'rgb8unorm';\n          bytesPerPixel = 3;\n        }\n      }\n\n      // TODO: A lot more possible formats to cover here.\n    }\n  }\n\n  let width = header[off_width];\n  let height = header[off_height];\n  let dataOffset = header[off_size] + 4;\n\n  if (supportedFormats.indexOf(internalFormat) == -1) {\n    if (internalFormat === 'bc1-rgb-unorm' && supportedFormats.indexOf('rgb565unorm') != -1) {\n      // Allow a fallback to rgb565 if it's bc1 and we don't support it natively.\n      internalFormat = 'rgb565unorm';\n      bytesPerPixel = 2;\n      buffer = dxtToRgb565(new Uint16Array(buffer), dataOffset / 2, width, height).buffer;\n      dataOffset = 0;\n    } else {\n      throw new Error(`Unsupported\n       texture format: ${int32ToFourCC(fourCC)} ${internalFormat}`);\n    }\n  }\n\n  if (blockBytes == 0) {\n    return new WorkerTextureData({\n      format: internalFormat, width, height,\n      imageData: buffer,\n      imageDataOptions: {\n        byteOffset: dataOffset,\n        byteLength: width * height * bytesPerPixel\n      }\n    });\n  }\n\n  let mipmapCount = 1;\n  if(header[off_flags] & DDSD_MIPMAPCOUNT && mipmaps !== false) {\n      mipmapCount = Math.max(1, header[off_mipmapCount]);\n  }\n\n  const textureData = new WorkerTextureData({format: internalFormat, width, height});\n  for(let level = 0; level < mipmapCount; ++level) {\n    const textureLevel = textureData.getLevel(level);\n    const byteLength = blockBytes ? Math.max(4, width)/4 * Math.max(4, height)/4 * blockBytes :\n                                    width * height * 4;\n\n    textureLevel.setSlice(0, buffer, {\n      byteOffset: dataOffset,\n      byteLength\n    });\n\n    dataOffset += byteLength;\n    width = Math.max(1, Math.ceil(width / 2));\n    height = Math.max(1, Math.ceil(height / 2));\n  }\n\n  return textureData;\n}\n\nonmessage = createTextureMessageHandler(parseFile);\n"],
  "mappings": "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",
  "names": []
}
