{
  "version": 3,
  "sources": ["src/workers/basis/basis-worker.js"],
  "sourcesContent": ["// Copyright 2020 Brandon Jones\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated\n// documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in all copies or substantial portions of the\n// Software.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE\n// WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n/**\n * @file Web Worker for transcoding Basis Universal files\n * @module BasisLoader\n *\n * Based on similar loader code I contributed to https://github.com/BinomialLLC/basis_universal\n * Edited to meet the abstraction needs of this library. This worker handles texture transcoding to avoid blocking the\n * main thread. Majority of the work is handled by Web Assembly code in basis_transcoder.wasm.\n */\n\nimportScripts('../worker-util.js');\nimportScripts('basis_transcoder.js');\n\n// eslint-disable-next-line new-cap\nconst BASIS_TRANSCODER = new Promise((resolve) => {\n  // Turns out this isn't a \"real\" promise, so we can't use it with await later on. Hence the wrapper promise.\n  // eslint-disable-next-line new-cap\n  BASIS().then((module) => {\n    module.initializeBasis();\n    resolve(module.BasisFile);\n  });\n});\n\n// Copied from enum class transcoder_texture_format in basisu_transcoder.h with minor javascript-ification\n/* eslint-disable */\nconst BASIS_FORMAT = {\n  // Compressed formats\n\n  // ETC1-2\n  cTFETC1_RGB: 0,\t\t\t\t\t\t\t// Opaque only, returns RGB or alpha data if cDecodeFlagsTranscodeAlphaDataToOpaqueFormats flag is specified\n  cTFETC2_RGBA: 1,\t\t\t\t\t\t// Opaque+alpha, ETC2_EAC_A8 block followed by a ETC1 block, alpha channel will be opaque for opaque .basis files\n\n  // BC1-5, BC7 (desktop, some mobile devices)\n  cTFBC1_RGB: 2,\t\t\t\t\t\t\t// Opaque only, no punchthrough alpha support yet, transcodes alpha slice if cDecodeFlagsTranscodeAlphaDataToOpaqueFormats flag is specified\n  cTFBC3_RGBA: 3, \t\t\t\t\t\t// Opaque+alpha, BC4 followed by a BC1 block, alpha channel will be opaque for opaque .basis files\n  cTFBC4_R: 4,\t\t\t\t\t\t\t\t// Red only, alpha slice is transcoded to output if cDecodeFlagsTranscodeAlphaDataToOpaqueFormats flag is specified\n  cTFBC5_RG: 5,\t\t\t\t\t\t\t\t// XY: Two BC4 blocks, X=R and Y=Alpha, .basis file should have alpha data (if not Y will be all 255's)\n  cTFBC7_RGBA: 6,\t\t\t\t\t\t\t// RGB or RGBA, mode 5 for ETC1S, modes (1,2,3,5,6,7) for UASTC\n\n  // PVRTC1 4bpp (mobile, PowerVR devices)\n  cTFPVRTC1_4_RGB: 8,\t\t\t\t\t// Opaque only, RGB or alpha if cDecodeFlagsTranscodeAlphaDataToOpaqueFormats flag is specified, nearly lowest quality of any texture format.\n  cTFPVRTC1_4_RGBA: 9,\t\t\t\t// Opaque+alpha, most useful for simple opacity maps. If .basis file doesn't have alpha cTFPVRTC1_4_RGB will be used instead. Lowest quality of any supported texture format.\n\n  // ASTC (mobile, Intel devices, hopefully all desktop GPU's one day)\n  cTFASTC_4x4_RGBA: 10,\t\t\t\t// Opaque+alpha, ASTC 4x4, alpha channel will be opaque for opaque .basis files. Transcoder uses RGB/RGBA/L/LA modes, void extent, and up to two ([0,47] and [0,255]) endpoint precisions.\n\n  // Uncompressed (raw pixel) formats\n  cTFRGBA32: 13,\t\t\t\t\t\t\t// 32bpp RGBA image stored in raster (not block) order in memory, R is first byte, A is last byte.\n  cTFRGB565: 14,\t\t\t\t\t\t\t// 166pp RGB image stored in raster (not block) order in memory, R at bit position 11\n  cTFBGR565: 15,\t\t\t\t\t\t\t// 16bpp RGB image stored in raster (not block) order in memory, R at bit position 0\n  cTFRGBA4444: 16,\t\t\t\t\t\t// 16bpp RGBA image stored in raster (not block) order in memory, R at bit position 12, A at bit position 0\n\n  cTFTotalTextureFormats: 22,\n};\n/* eslint-enable */\n\nconst WTT_FORMAT_MAP = {};\n// Compressed formats\nWTT_FORMAT_MAP[BASIS_FORMAT.cTFBC1_RGB] = {format: 'bc1-rgb-unorm'};\nWTT_FORMAT_MAP[BASIS_FORMAT.cTFBC3_RGBA] = {format: 'bc3-rgba-unorm'};\nWTT_FORMAT_MAP[BASIS_FORMAT.cTFBC7_RGBA] = {format: 'bc7-rgba-unorm'};\nWTT_FORMAT_MAP[BASIS_FORMAT.cTFETC1_RGB] = {format: 'etc1-rgb-unorm'};\nWTT_FORMAT_MAP[BASIS_FORMAT.cTFETC2_RGBA] = {format: 'etc2-rgba8unorm'};\nWTT_FORMAT_MAP[BASIS_FORMAT.cTFASTC_4x4_RGBA] = {format: 'astc-4x4-rgba-unorm'};\nWTT_FORMAT_MAP[BASIS_FORMAT.cTFPVRTC1_4_RGB] = {format: 'pvrtc1-4bpp-rgb-unorm'};\nWTT_FORMAT_MAP[BASIS_FORMAT.cTFPVRTC1_4_RGBA] = {format: 'pvrtc1-4bpp-rgba-unorm'};\n\n// Uncompressed formats\nWTT_FORMAT_MAP[BASIS_FORMAT.cTFRGBA32] = {format: 'rgba8unorm', uncompressed: true};\nWTT_FORMAT_MAP[BASIS_FORMAT.cTFRGB565] = {format: 'rgb565unorm', uncompressed: true};\nWTT_FORMAT_MAP[BASIS_FORMAT.cTFRGBA4444] = {format: 'rgba4unorm', uncompressed: true};\n\n// This utility currently only transcodes the first image in the file.\nconst IMAGE_INDEX = 0;\n\n/**\n * Transcodes basis universal texture data into the optimal supported format and sends the resulting data back to the\n * main thread.\n *\n * @param {module:External.ArrayBufferView} arrayBuffer - Array buffer containing the data to transcode.\n * @param {Array<module:WebTextureTool.WebTextureFormat>} supportedFormats - Formats which the target API can support.\n * @param {boolean} mipmaps - True if all available mip levels should be transcoded.\n * @returns {void}\n */\nasync function transcodeBasisFile(arrayBuffer, supportedFormats, mipmaps) {\n  const BasisFile = await BASIS_TRANSCODER;\n\n  // The formats this device supports\n  const supportedBasisFormats = {};\n  // eslint-disable-next-line guard-for-in\n  for (const targetFormat in WTT_FORMAT_MAP) {\n    const wttFormat = WTT_FORMAT_MAP[targetFormat];\n    supportedBasisFormats[targetFormat] = supportedFormats.indexOf(wttFormat.format) > -1;\n  }\n\n  const basisData = new Uint8Array(arrayBuffer);\n\n  const basisFile = new BasisFile(basisData);\n  const images = basisFile.getNumImages();\n  const hasAlpha = basisFile.getHasAlpha();\n  let levels = basisFile.getNumLevels(IMAGE_INDEX);\n\n  try {\n    if (!images || !levels) {\n      throw new Error('Invalid Basis data');\n    }\n\n    if (!basisFile.startTranscoding()) {\n      throw new Error('startTranscoding failed');\n    }\n\n    let basisFormat = undefined;\n    if (hasAlpha) {\n      if (supportedBasisFormats[BASIS_FORMAT.cTFETC2_RGBA]) {\n        basisFormat = BASIS_FORMAT.cTFETC2_RGBA;\n      } else if (supportedBasisFormats[BASIS_FORMAT.cTFBC7_RGBA]) {\n        basisFormat = BASIS_FORMAT.cTFBC7_RGBA;\n      } else if (supportedBasisFormats[BASIS_FORMAT.cTFBC3_RGBA]) {\n        basisFormat = BASIS_FORMAT.cTFBC3_RGBA;\n      } else if (supportedBasisFormats[BASIS_FORMAT.cTFASTC_4x4_RGBA]) {\n        basisFormat = BASIS_FORMAT.cTFASTC_4x4_RGBA;\n      } else if (supportedBasisFormats[BASIS_FORMAT.cTFPVRTC1_4_RGBA]) {\n        basisFormat = BASIS_FORMAT.cTFPVRTC1_4_RGBA;\n      } else {\n        // If we don't support any appropriate compressed formats transcode to\n        // raw pixels. This is something of a last resort, because the GPU\n        // upload will be significantly slower and take a lot more memory, but\n        // at least it prevents you from needing to store a fallback JPG/PNG and\n        // the download size will still likely be smaller.\n        basisFormat = BASIS_FORMAT.cTFRGBA32;\n      }\n    } else {\n      if (supportedBasisFormats[BASIS_FORMAT.cTFETC1_RGB]) {\n        // Should be the highest quality, so use when available.\n        // http://richg42.blogspot.com/2018/05/basis-universal-gpu-texture-format.html\n        basisFormat = BASIS_FORMAT.cTFETC1_RGB;\n      } else if (supportedBasisFormats[BASIS_FORMAT.cTFBC7_RGBA]) {\n        basisFormat = BASIS_FORMAT.cTFBC7_RGBA;\n      } else if (supportedBasisFormats[BASIS_FORMAT.cTFBC1_RGB]) {\n        basisFormat = BASIS_FORMAT.cTFBC1_RGB;\n      } else if (supportedBasisFormats[BASIS_FORMAT.cTFETC2_RGBA]) {\n        basisFormat = BASIS_FORMAT.cTFETC2_RGBA;\n      } else if (supportedBasisFormats[BASIS_FORMAT.cTFASTC_4x4_RGBA]) {\n        basisFormat = BASIS_FORMAT.cTFASTC_4x4_RGBA;\n      } else if (supportedBasisFormats[BASIS_FORMAT.cTFPVRTC1_4_RGB]) {\n        basisFormat = BASIS_FORMAT.cTFPVRTC1_4_RGB;\n      } else if (supportedBasisFormats[BASIS_FORMAT.cTFRGB565]) {\n        // See note on uncompressed transcode above.\n        basisFormat = BASIS_FORMAT.cTFRGB565;\n      } else {\n        // See note on uncompressed transcode above.\n        basisFormat = BASIS_FORMAT.cTFRGBA32;\n      }\n    }\n\n    if (basisFormat === undefined) {\n      throw new Error('No supported transcode formats');\n    }\n\n    const wttFormat = WTT_FORMAT_MAP[basisFormat];\n\n    // If we're not using compressed textures or we've been explicitly instructed to not unpack mipmaps only transcode a\n    // single level.\n    if (wttFormat.uncompressed || !mipmaps) {\n      levels = 1;\n    }\n\n    const textureData = new WorkerTextureData({\n      format: wttFormat.format,\n      width: basisFile.getImageWidth(0, 0),\n      height: basisFile.getImageHeight(0, 0),\n    });\n\n    // Transcode each mip level.\n    for (let levelIndex = 0; levelIndex < levels; ++levelIndex) {\n      const level = textureData.getLevel(levelIndex, {\n        width: basisFile.getImageWidth(0, levelIndex),\n        height: basisFile.getImageHeight(0, levelIndex),\n      });\n\n      for (let sliceIndex = 0; sliceIndex < images; ++sliceIndex) {\n        const transcodeSize = basisFile.getImageTranscodedSizeInBytes(sliceIndex, levelIndex, basisFormat);\n        const levelData = new Uint8Array(transcodeSize);\n        if (!basisFile.transcodeImage(levelData, sliceIndex, levelIndex, basisFormat, 1, 0)) {\n          throw new Error('transcodeImage failed');\n        }\n        level.setSlice(sliceIndex, levelData);\n      }\n    }\n\n    // Post the transcoded results back to the main thread.\n    return textureData;\n  } finally {\n    // Make sure we close the basisFile\n    basisFile.close();\n    basisFile.delete();\n  }\n}\n\nonmessage = createTextureMessageHandler(transcodeBasisFile);\n"],
  "mappings": "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",
  "names": []
}
